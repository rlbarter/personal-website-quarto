{"title":"mutate_all(), select_if(), summarise_at()... what's the deal with scoped verbs?!","markdown":{"yaml":{"title":"mutate_all(), select_if(), summarise_at()... what's the deal with scoped verbs?!","author":"Rebecca Barter","format":{"html":{"toc":true,"toc-location":"left"}},"categories":["dplyr","R","tidyverse"],"date":"2019-01-23","description":"What's the deal with these mutate_all(), select_if(), summarise_at(), functions? They seem so useful, but there doesn't seem to be a decent explanation of how to use them anywhere on the internet. Turns out, they're called 'scoped verbs' and hopefully this post will become one of many decent explanations of how to use them!"},"headingText":"load in the only library you ever really need","containsRefs":false,"markdown":"\n\nNote: Scoped verbs have now essentially been superseded by `accross()` (soon to be available in dplyr 1.0.0). See [http://www.rebeccabarter.com/blog/2020-07-09-across/](http://www.rebeccabarter.com/blog/2020-07-09-across/) for details. \n\n\nI often find myself wishing that I could apply the same `mutate` function to several columns in a data frame at once, such as convert all factors to characters, or do something to all columns that have missing values, or select all variables whose names end with `_important`. When I first googled these problems around a year ago, I started to see solutions that use weird extensions of the basic `mutate()`, `select()`, `rename()`, and `summarise()` dplyr functions that look like `summarise_all()`, `filter_at()`, `mutate_if()`, and so on. I have since learned that these functions are called **\"scoped verbs\"** (where \"scoped\" means that they operate only on a selection of variables).\n\nUnfortunately, despite my extensive googling, I never really found a satisfactory description of *how* to use these functions in general, I think primarily because the documentation for these functions is not particularly useful (try `?mutate_at()`).\n\nFortunately, I recently attended a series of lightening talks hosted by the RLadies SF chapter where Sara Altman pointed us towards a [summary document](https://dcl-2017-04.github.io/curriculum/manip-scoped.html) that Hadley Wickham wrote for the Data Science class he helped create at Stanford in 2017 (this class is now taught by Sara Altman herself). \n\nTo summarise what I will demonstrate below, there are three scoped variants of the standard `mutate`, `summarise`, `rename` and `select` (and `transmute`) dplyr functions that can be specified by the following suffixes:\n\n- `_if`: allows you to pick variables that satisfy some logical criteria such as `is.numeric()` or `is.character()` (e.g. summarising only the numeric columns)\n\n- `_at`: allows you to perform an operation only on variables specified by name (e.g. mutating only the columns whose name ends with \"_date\")\n\n- `_all`: allows you to perform an operation on all variables at once (e.g. calculating the number of missing values in every column)\n\n\nTo explain how these functions all work, I will use the dataset from a survey of 800 Pittsburgh residents on whether or not they approve of self-driving car companies testing their autonomous vehicles on the streets of Pittsburgh (there have several articles on this issue in recent times in case you missed them: [1](https://www.wired.com/story/uber-returns-self-driving-after-deadly-crash/), [2](https://www.nytimes.com/2018/12/05/technology/uber-self-driving-cars.html)). The data can usually be downloaded from data.gov (but is currently unavailable due to the current Government Shutdown - I will update this with an actual link to the data one day). For now you can download the data from [here](/data/bikepghpublic.csv).\n\nA random sample of 10 rows of this dataset is shown below. To make it easy to see what's going on, I'll restrict my analysis below to these 10 rows\n\n```{r, message=FALSE}\nlibrary(tidyverse)\nlibrary(lubridate)\n# load in survey data\nav_survey <- read_csv(\"data/bikepghpublic.csv\")\n```\n\n\n```{r}\nset.seed(45679)\nav_survey_sample <- av_survey %>% \n  # select jsut a few columns and give some more intuitive column names\n  select(id = `Response ID`,\n         start_date = `Start Date`, \n         end_date = `End Date`,\n         interacted_with_av_as_pedestrian = InteractPedestrian,\n         interacted_with_av_as_cyclist = InteractBicycle,\n         circumstanses_of_interaction = CircumstancesCoded, # lol @ typo in data\n         approve_av_testing_pgh = FeelingsProvingGround) %>%\n  # take a random sample of 10 rows\n  sample_n(10) %>%\n  # make data frame so that we view the whole thing\n  as.data.frame()\nav_survey_sample\n```\n\n\n\n# A quick useful aside: Using shorthand for functions\n\nFor many of the examples below, I will be using the `~fun(.x)` shorthand for writing temporary functions. If you've never seen this shorthand before it's incredibly useful. As an example, here are three ways of counting the number of missing values in each column of a data frame. \n\nThe first approach uses the traditional `sapply()` function and temporary function syntax. \n\n```{r}\n# using apply and the normal temporary function syntax\nsapply(av_survey_sample, function(x) sum(is.na(x)))\n```\n\nThe second still uses the temporary function syntax, but is using the `map_dbl()` function from the `purrr` package instead of the old-school `sapply()` function.\n```{r}\n# using purrr::map_dbl and the normal temporary function syntax\nav_survey_sample %>% map_dbl(function(x) sum(is.na(x)))\n```\n\nThe third uses the `map_dbl()` function with the `~fun(.x)` syntax.\n```{r}\n# using purrr::map_dbl and the `~fun(.x)` temporary function syntax\nav_survey_sample %>% map_dbl(~sum(is.na(.x)))\n```\n\n\n# The _if() scoped variant: perform an operation on variables that satisfy a logical criteria\n\n`_if` allows you to perform an operation on variables that satisfy some logical criteria such as `is.numeric()` or `is.character()`.\n\n## select_if()\n\nFor instance, we can use `select_if()` to extract the numeric columns of the tibble only.\n\n```{r}\nav_survey_sample %>% select_if(is.numeric)\n```\n\nWe could also apply use more complex logical statements, for example by selecting columns that have at least one missing value. \n\n```{r}\nav_survey_sample %>% \n  # select columns with at least one NA\n  # the expression evaluates to TRUE if there is one or more missing values\n  select_if(~sum(is.na(.x)) > 0) \n```\n\n## rename_if()\n\nWe could rename columns that satisfy a logical expression using `rename_if()`. For instance, we can add a `num_` prefix to all numeric column names.\n\n```{r}\nav_survey_sample %>%\n  # only rename numeric columns by adding a \"num_\" prefix\n  rename_if(is.numeric, ~paste0(\"num_\", .x))\n```\n\n## mutate_if()\n\nWe could similarly use `mutate_if()` to mutate columns that satisfy specified logical conditions. In the example below, we mutate all columns that have at least one missing value by replacing `NA` with `\"missing\"`.\n\n```{r}\nav_survey_sample %>% \n  # only mutate columns with at least one NA\n  # replace each NA value with the character \"missing\"\n  mutate_if(~sum(is.na(.x)) > 0,\n            ~if_else(is.na(.x), \"missing\", as.character(.x)))\n```\n\n## summarise_if()\n\nSimilarly, `summarise_if()` will summarise columns that satisfy the specified logical conditions. Below, we summarise each character column by reporting the most common value (but for some reason there is no `mode()` function in R, so we need to write our own).\n\n```{r}\n# function to calculate the mode (most common) observation\nmode <- function(x) {\n  names(sort(table(x)))[1]\n}\n# summarise character\nav_survey_sample %>% \n  summarise_if(is.character, mode)\n```\n\n\n\n# The _at() scoped variant: perform an operation only on variables specified by name\n\n`_at` allows you to perform an operation only on variables specified by name.\n\nTo specify which variables you want to operate on, you need to include the variable names inside the `vars()` function as the first argument. I think of as like `vars()` like `c()` to provide multiple values (in this case variable names) as a single argument. For example `av_survey_sample %>% mutate_at(vars(start_date, end_date), mdy_hms)` will only mutate the `start_date` and `end_date` variables by converting them to lubridate format using the `mdy_hms` function.\n\nThese variables can be specified explicitly by name within the `vars()` function, or using the **select_helpers** within the `vars()` function.\n\n## Select helpers\n\nSelect helpers are functions that you can use within `select()` to help specify which variables you want to select. The options are\n\n- `starts_with()`: select all variables that start with a specified character string\n\n- `ends_with()`: select all variables that end with a specified character string\n\n- `contains()`: select all variables that contain a specified character string\n\n- `matches()`: select variables that match a specified character string\n\n- `one_of()`: selects variables that match any entries in the specified character vector\n\n- `num_range()`: selects variables that are numbered (e.g. columns named `V1`, `V2`, `V3` would be selected by `select(num_range(\"V\", 1:3))`)\n\nThere are many ways that we could select the `date` variables using the `ends_with()` and `contains()` select helpers:\n\n```{r}\n# selecting the date columns by providing their names\nav_survey_sample %>% select(start_date, end_date)\n# selecting the columns that end with \"_date\"\nav_survey_sample %>% select(ends_with(\"_date\"))\n# selecting the columns that contain \"date\"\nav_survey_sample %>% select(contains(\"date\"))\n```\n\nIf you ever find yourself wanting to provide variable names as characters, the `matches()` and `one_of()` select helpers can help you do that.\n\n```{r}\n# provide matches with a single character variables\nvariable <- \"start_date\"\nav_survey_sample %>% select(matches(variable))\n# provide one_of with a vector of character variables\nvariables <- c(\"start_date\", \"end_date\")\nav_survey_sample %>% select(one_of(variables))\n```\n\nNote that technically there does exist a `select_at()` function that requires a `vars()` input, but I can't really think of a good use of this function...\n```{r}\n# this is the same as av_survey_sample %>% select(start_date, end_date)\nav_survey_sample %>% \n  select_at(vars(start_date, end_date))\n```\n\nThe syntax of this `select_at()` example though can be useful for understanding how the `vars()` function can be used in the other `_at()` functions).\n\n## rename_at()\n\nYou can rename specified variables using the `rename_at()` function. For instance, we could replace all column names that contain the character string \"av\" with the same column name but an uppercase \"AV\" instead of the original lowercase \"av\".\n\nTo do this, we use the select helper `contains()` within the `vars()` function.\n\n```{r}\n# use a select helper to only apply to columns whose name contains \"av\"\n# then rename these columns with \"AV\" in place of \"av\"\nav_survey_sample %>% \n  rename_at(vars(contains(\"av\")), \n            ~gsub(\"av\", \"AV\", .x))\n```\n\n\n## mutate_at()\n\nTo mutate only the date variables, normally we would do the `mdy_hms()` transformation to each variable separately as follows:\n```{r}\n# use the standard (unscoped) approach\nav_survey_sample %>% \n  mutate(start_date = mdy_hms(start_date),\n         end_date = mdy_hms(end_date))\n```\n\nHowever, using `mutate_at()` and supplying these column names as arguments to the `vars()` function, we could specify the function only once. \n```{r}\n# specifying specific variables to apply the same function to\nav_survey_sample %>% \n  mutate_at(vars(start_date, end_date), mdy_hms)\n```\n\nMoreover, we can use the select helpers to specify which columns we want to mutate, without having to write out the entire column names.\n```{r}\n# use a \"select helper\" to specify the variables that end with \"_date\"\nav_survey_sample %>% \n  mutate_at(vars(ends_with(\"_date\")), mdy_hms)\n```\n\n\n## summarise_at()\n\nThe `summarise_at()` scoped verb behaves very similarly to the `mutate_at()` scoped verb, in that we can easily specify *which* variables we want to apply the same summary function to.\n\nFor instance, the following example summarises all variables that contain the word \"interacted\" by counting the number of \"Yes\" entries.\n\n```{r}\nav_survey_sample %>% \n  summarise_at(vars(contains(\"interacted\")), ~sum(.x == \"Yes\"))\n```\n\n\n# The _all() scoped variant: perform an operation on all variables at once\n\n`_all` allows you to perform an operation on all variables at once (e.g. calculating the number of missing values in every column).\n\n## rename_all()\n\nThe `select_all()` would is quite redundant (it would simply return all columns). Its friend `rename_all()`, however can be very useful. \n\nFor instance, we could rename all variables by replacing underscores `_` with dots `.` (although I would advise against this: underscores are way better than dots!).\n\n```{r}\nav_survey_sample %>% \n  rename_all(~gsub(\"_\", \".\", .x))\n```\n\n## mutate_all()\n\nWe could apply the same mutate function to every column at once using `mutate_all()`. For instance, the code below converts every column to a numeric (although this results in mostly missing values for the character variables)\n\n```{r, warning=FALSE}\nav_survey_sample %>%\n  mutate_all(as.numeric)\n```\n\n\n## summarise_all()\n\nWe could also apply the same summary function to every column at once using `summarise_all()`. For instance, the example below calculates the number of distinct entries in each column.\n\n```{r}\nav_survey_sample %>%\n  summarise_all(n_distinct)\n```\n\n\n# Conclusion\n\nHopefully this summary is useful to you in your data manipulation adventures! \n\n","srcMarkdownNoYaml":"\n\nNote: Scoped verbs have now essentially been superseded by `accross()` (soon to be available in dplyr 1.0.0). See [http://www.rebeccabarter.com/blog/2020-07-09-across/](http://www.rebeccabarter.com/blog/2020-07-09-across/) for details. \n\n\nI often find myself wishing that I could apply the same `mutate` function to several columns in a data frame at once, such as convert all factors to characters, or do something to all columns that have missing values, or select all variables whose names end with `_important`. When I first googled these problems around a year ago, I started to see solutions that use weird extensions of the basic `mutate()`, `select()`, `rename()`, and `summarise()` dplyr functions that look like `summarise_all()`, `filter_at()`, `mutate_if()`, and so on. I have since learned that these functions are called **\"scoped verbs\"** (where \"scoped\" means that they operate only on a selection of variables).\n\nUnfortunately, despite my extensive googling, I never really found a satisfactory description of *how* to use these functions in general, I think primarily because the documentation for these functions is not particularly useful (try `?mutate_at()`).\n\nFortunately, I recently attended a series of lightening talks hosted by the RLadies SF chapter where Sara Altman pointed us towards a [summary document](https://dcl-2017-04.github.io/curriculum/manip-scoped.html) that Hadley Wickham wrote for the Data Science class he helped create at Stanford in 2017 (this class is now taught by Sara Altman herself). \n\nTo summarise what I will demonstrate below, there are three scoped variants of the standard `mutate`, `summarise`, `rename` and `select` (and `transmute`) dplyr functions that can be specified by the following suffixes:\n\n- `_if`: allows you to pick variables that satisfy some logical criteria such as `is.numeric()` or `is.character()` (e.g. summarising only the numeric columns)\n\n- `_at`: allows you to perform an operation only on variables specified by name (e.g. mutating only the columns whose name ends with \"_date\")\n\n- `_all`: allows you to perform an operation on all variables at once (e.g. calculating the number of missing values in every column)\n\n\nTo explain how these functions all work, I will use the dataset from a survey of 800 Pittsburgh residents on whether or not they approve of self-driving car companies testing their autonomous vehicles on the streets of Pittsburgh (there have several articles on this issue in recent times in case you missed them: [1](https://www.wired.com/story/uber-returns-self-driving-after-deadly-crash/), [2](https://www.nytimes.com/2018/12/05/technology/uber-self-driving-cars.html)). The data can usually be downloaded from data.gov (but is currently unavailable due to the current Government Shutdown - I will update this with an actual link to the data one day). For now you can download the data from [here](/data/bikepghpublic.csv).\n\nA random sample of 10 rows of this dataset is shown below. To make it easy to see what's going on, I'll restrict my analysis below to these 10 rows\n\n```{r, message=FALSE}\n# load in the only library you ever really need\nlibrary(tidyverse)\nlibrary(lubridate)\n# load in survey data\nav_survey <- read_csv(\"data/bikepghpublic.csv\")\n```\n\n\n```{r}\nset.seed(45679)\nav_survey_sample <- av_survey %>% \n  # select jsut a few columns and give some more intuitive column names\n  select(id = `Response ID`,\n         start_date = `Start Date`, \n         end_date = `End Date`,\n         interacted_with_av_as_pedestrian = InteractPedestrian,\n         interacted_with_av_as_cyclist = InteractBicycle,\n         circumstanses_of_interaction = CircumstancesCoded, # lol @ typo in data\n         approve_av_testing_pgh = FeelingsProvingGround) %>%\n  # take a random sample of 10 rows\n  sample_n(10) %>%\n  # make data frame so that we view the whole thing\n  as.data.frame()\nav_survey_sample\n```\n\n\n\n# A quick useful aside: Using shorthand for functions\n\nFor many of the examples below, I will be using the `~fun(.x)` shorthand for writing temporary functions. If you've never seen this shorthand before it's incredibly useful. As an example, here are three ways of counting the number of missing values in each column of a data frame. \n\nThe first approach uses the traditional `sapply()` function and temporary function syntax. \n\n```{r}\n# using apply and the normal temporary function syntax\nsapply(av_survey_sample, function(x) sum(is.na(x)))\n```\n\nThe second still uses the temporary function syntax, but is using the `map_dbl()` function from the `purrr` package instead of the old-school `sapply()` function.\n```{r}\n# using purrr::map_dbl and the normal temporary function syntax\nav_survey_sample %>% map_dbl(function(x) sum(is.na(x)))\n```\n\nThe third uses the `map_dbl()` function with the `~fun(.x)` syntax.\n```{r}\n# using purrr::map_dbl and the `~fun(.x)` temporary function syntax\nav_survey_sample %>% map_dbl(~sum(is.na(.x)))\n```\n\n\n# The _if() scoped variant: perform an operation on variables that satisfy a logical criteria\n\n`_if` allows you to perform an operation on variables that satisfy some logical criteria such as `is.numeric()` or `is.character()`.\n\n## select_if()\n\nFor instance, we can use `select_if()` to extract the numeric columns of the tibble only.\n\n```{r}\nav_survey_sample %>% select_if(is.numeric)\n```\n\nWe could also apply use more complex logical statements, for example by selecting columns that have at least one missing value. \n\n```{r}\nav_survey_sample %>% \n  # select columns with at least one NA\n  # the expression evaluates to TRUE if there is one or more missing values\n  select_if(~sum(is.na(.x)) > 0) \n```\n\n## rename_if()\n\nWe could rename columns that satisfy a logical expression using `rename_if()`. For instance, we can add a `num_` prefix to all numeric column names.\n\n```{r}\nav_survey_sample %>%\n  # only rename numeric columns by adding a \"num_\" prefix\n  rename_if(is.numeric, ~paste0(\"num_\", .x))\n```\n\n## mutate_if()\n\nWe could similarly use `mutate_if()` to mutate columns that satisfy specified logical conditions. In the example below, we mutate all columns that have at least one missing value by replacing `NA` with `\"missing\"`.\n\n```{r}\nav_survey_sample %>% \n  # only mutate columns with at least one NA\n  # replace each NA value with the character \"missing\"\n  mutate_if(~sum(is.na(.x)) > 0,\n            ~if_else(is.na(.x), \"missing\", as.character(.x)))\n```\n\n## summarise_if()\n\nSimilarly, `summarise_if()` will summarise columns that satisfy the specified logical conditions. Below, we summarise each character column by reporting the most common value (but for some reason there is no `mode()` function in R, so we need to write our own).\n\n```{r}\n# function to calculate the mode (most common) observation\nmode <- function(x) {\n  names(sort(table(x)))[1]\n}\n# summarise character\nav_survey_sample %>% \n  summarise_if(is.character, mode)\n```\n\n\n\n# The _at() scoped variant: perform an operation only on variables specified by name\n\n`_at` allows you to perform an operation only on variables specified by name.\n\nTo specify which variables you want to operate on, you need to include the variable names inside the `vars()` function as the first argument. I think of as like `vars()` like `c()` to provide multiple values (in this case variable names) as a single argument. For example `av_survey_sample %>% mutate_at(vars(start_date, end_date), mdy_hms)` will only mutate the `start_date` and `end_date` variables by converting them to lubridate format using the `mdy_hms` function.\n\nThese variables can be specified explicitly by name within the `vars()` function, or using the **select_helpers** within the `vars()` function.\n\n## Select helpers\n\nSelect helpers are functions that you can use within `select()` to help specify which variables you want to select. The options are\n\n- `starts_with()`: select all variables that start with a specified character string\n\n- `ends_with()`: select all variables that end with a specified character string\n\n- `contains()`: select all variables that contain a specified character string\n\n- `matches()`: select variables that match a specified character string\n\n- `one_of()`: selects variables that match any entries in the specified character vector\n\n- `num_range()`: selects variables that are numbered (e.g. columns named `V1`, `V2`, `V3` would be selected by `select(num_range(\"V\", 1:3))`)\n\nThere are many ways that we could select the `date` variables using the `ends_with()` and `contains()` select helpers:\n\n```{r}\n# selecting the date columns by providing their names\nav_survey_sample %>% select(start_date, end_date)\n# selecting the columns that end with \"_date\"\nav_survey_sample %>% select(ends_with(\"_date\"))\n# selecting the columns that contain \"date\"\nav_survey_sample %>% select(contains(\"date\"))\n```\n\nIf you ever find yourself wanting to provide variable names as characters, the `matches()` and `one_of()` select helpers can help you do that.\n\n```{r}\n# provide matches with a single character variables\nvariable <- \"start_date\"\nav_survey_sample %>% select(matches(variable))\n# provide one_of with a vector of character variables\nvariables <- c(\"start_date\", \"end_date\")\nav_survey_sample %>% select(one_of(variables))\n```\n\nNote that technically there does exist a `select_at()` function that requires a `vars()` input, but I can't really think of a good use of this function...\n```{r}\n# this is the same as av_survey_sample %>% select(start_date, end_date)\nav_survey_sample %>% \n  select_at(vars(start_date, end_date))\n```\n\nThe syntax of this `select_at()` example though can be useful for understanding how the `vars()` function can be used in the other `_at()` functions).\n\n## rename_at()\n\nYou can rename specified variables using the `rename_at()` function. For instance, we could replace all column names that contain the character string \"av\" with the same column name but an uppercase \"AV\" instead of the original lowercase \"av\".\n\nTo do this, we use the select helper `contains()` within the `vars()` function.\n\n```{r}\n# use a select helper to only apply to columns whose name contains \"av\"\n# then rename these columns with \"AV\" in place of \"av\"\nav_survey_sample %>% \n  rename_at(vars(contains(\"av\")), \n            ~gsub(\"av\", \"AV\", .x))\n```\n\n\n## mutate_at()\n\nTo mutate only the date variables, normally we would do the `mdy_hms()` transformation to each variable separately as follows:\n```{r}\n# use the standard (unscoped) approach\nav_survey_sample %>% \n  mutate(start_date = mdy_hms(start_date),\n         end_date = mdy_hms(end_date))\n```\n\nHowever, using `mutate_at()` and supplying these column names as arguments to the `vars()` function, we could specify the function only once. \n```{r}\n# specifying specific variables to apply the same function to\nav_survey_sample %>% \n  mutate_at(vars(start_date, end_date), mdy_hms)\n```\n\nMoreover, we can use the select helpers to specify which columns we want to mutate, without having to write out the entire column names.\n```{r}\n# use a \"select helper\" to specify the variables that end with \"_date\"\nav_survey_sample %>% \n  mutate_at(vars(ends_with(\"_date\")), mdy_hms)\n```\n\n\n## summarise_at()\n\nThe `summarise_at()` scoped verb behaves very similarly to the `mutate_at()` scoped verb, in that we can easily specify *which* variables we want to apply the same summary function to.\n\nFor instance, the following example summarises all variables that contain the word \"interacted\" by counting the number of \"Yes\" entries.\n\n```{r}\nav_survey_sample %>% \n  summarise_at(vars(contains(\"interacted\")), ~sum(.x == \"Yes\"))\n```\n\n\n# The _all() scoped variant: perform an operation on all variables at once\n\n`_all` allows you to perform an operation on all variables at once (e.g. calculating the number of missing values in every column).\n\n## rename_all()\n\nThe `select_all()` would is quite redundant (it would simply return all columns). Its friend `rename_all()`, however can be very useful. \n\nFor instance, we could rename all variables by replacing underscores `_` with dots `.` (although I would advise against this: underscores are way better than dots!).\n\n```{r}\nav_survey_sample %>% \n  rename_all(~gsub(\"_\", \".\", .x))\n```\n\n## mutate_all()\n\nWe could apply the same mutate function to every column at once using `mutate_all()`. For instance, the code below converts every column to a numeric (although this results in mostly missing values for the character variables)\n\n```{r, warning=FALSE}\nav_survey_sample %>%\n  mutate_all(as.numeric)\n```\n\n\n## summarise_all()\n\nWe could also apply the same summary function to every column at once using `summarise_all()`. For instance, the example below calculates the number of distinct entries in each column.\n\n```{r}\nav_survey_sample %>%\n  summarise_all(n_distinct)\n```\n\n\n# Conclusion\n\nHopefully this summary is useful to you in your data manipulation adventures! \n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"2019-01-23_scoped-verbs.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","theme":"simplex","linkcolor":"#6633c4","code-copy":true,"footnotes-hover":true,"title-block-banner":true,"comments":{"utterances":{"repo":"rlbarter/blog_comments"}},"title":"mutate_all(), select_if(), summarise_at()... what's the deal with scoped verbs?!","author":"Rebecca Barter","categories":["dplyr","R","tidyverse"],"date":"2019-01-23","description":"What's the deal with these mutate_all(), select_if(), summarise_at(), functions? They seem so useful, but there doesn't seem to be a decent explanation of how to use them anywhere on the internet. Turns out, they're called 'scoped verbs' and hopefully this post will become one of many decent explanations of how to use them!","toc-location":"left"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}