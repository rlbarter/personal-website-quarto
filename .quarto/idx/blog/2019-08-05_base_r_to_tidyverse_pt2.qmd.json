{"title":"Transitioning into the tidyverse (part 2)","markdown":{"yaml":{"title":"Transitioning into the tidyverse (part 2)","author":"Rebecca Barter","format":{"html":{"toc":true,"toc-location":"left"}},"categories":["R","tidyverse","tidyr","purrr","readr","tibbles","lubridate","forcats","stringr"],"date":"2019-08-05","description":"This post walks through what base R users need to know for their transition into the tidyverse. Part 2 focuses on the more specialized R packages tidyr, purrr, readr, lubridate, forcats, etc"},"headingText":"to download the data directly:","containsRefs":false,"markdown":"\n\n```{r echo = FALSE, fig.align = \"center\"}\nknitr::include_graphics(\"img/tidyverse/tidyverse_all.png\")\n```\n\nIf you're new to the tidyverse, I recommend that you first read [part one](http://www.rebeccabarter.com/blog/2019-08-05_base_r_to_tidyverse/) of this two-part series on transitioning into the tidyverse. Part 1 focuses on what I feel are the most important aspects and packages of the tidyverse: tidy thinking, piping, dplyr and ggplot2. \n\nThis second part of the two-part series focuses on the remaining (less essential, but still immensely useful) packages that make up the tidyverse: tidyr, purrr, readr, tibbles, as well as some additional type-specific packages (lubridate, forcats and stringr). Additional resources include the set of tidyverse [cheatsheets](https://www.rstudio.com/resources/cheatsheets/), as well as the [R for Data Science book](https://r4ds.had.co.nz/).\n\nStart by loading the tidyverse package into your environment.\n\n```{r, message=FALSE, warning=FALSE}\nlibrary(tidyverse)\n```\n\nThen load the gapminder data.\n\n\n```{r message=FALSE, warning=FALSE}\ngapminder_orig <- read.csv(\"https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder-FiveYearData.csv\")\n# define a copy of the original dataset that we will clean and play with \ngapminder <- gapminder_orig\n```\n\n\n# Data shaping: tidyr\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/tidyr.jpg\")\n```\n\nTidyr aims to help you reshape your data, and is very useful if you receive data in a format that isn't already \"tidy\". I also find myself using tidyr functions to help me calculate specific types of summaries and plots.\n\n\nFor instance, tidyr helps you convert your data between (a) long-form data where each variable is in a single column\n\n\n```{r echo = FALSE}\nlong <- gapminder %>%\n  filter(country %in% c(\"Australia\", \"United States\", \"Canada\"), year > 1990) %>%\n  select(country, year, lifeExp) \nlong \n```\n\nand (b) wide-form data where a single variable is separated into multiple columns based on some grouping (in this case, the life expectancy variable is separated into three columns, one for each country):\n\n```{r echo = FALSE}\nlong %>% mutate(country = paste0(country, \"_lifeExp\")) %>%\n  spread(key = country, \n                value = lifeExp) \n```\n\n\n## Gathering and spreading\n\nThe main tidyr functions are `spread()` and `gather()`. If you are familiar with the older reshape2 R package, you can think of tidyr as the tidyverse version, where `spread()` is the equivalent of `cast`, and `gather()` is the equivalent of `melt()`. If not... never mind!\n\nThink of `spread()` as a function that will spread a single variable's \"values\" across multiple columns based on a \"key\", or grouping variable. Similarly, think of `gather()` as a function that will gather a variable whose \"values\" are spread across multiple columns (where the \"key\" is the grouping variable that distinguishes the columns) into a single column. \n\nThe main things you need to figure out when using `spread()` and `gather()` are what are the \"key\" and what are the \"value\" columns of your data frame. If you are spreading your data (to make it wider), then your key and value variables are existing variables in the data. If you are gathering your data (making it longer), then you will need to define key and value variables that will become variable names in your long-form data frame. \n\nBelow I'll show how this works with a small subset of the gapminder dataset, corresponding to the life expectancy for US, Australia, and Canada for each year in the data after 1990. \n\n\nSuppose that you started with the long-form data.\n\n```{r}\ngapminder_sample_long <- gapminder %>%\n  filter(country %in% c(\"Australia\", \"United States\", \"Canada\"), year > 1990) %>%\n  select(country, year, lifeExp) \ngapminder_sample_long\n``` \n\nA wide-form version might have the life expectancy variable *spread* into three variables, one for each country (it would also be perfectly feasible to separate by year). So in this case, the **value** that you want to spread is the `lifeExp` variable, and the **key** that you want to spread/group by is the `country` variable.\n\n```{r}\ngapminder_sample_wide <- gapminder_sample_long %>% \n  spread(key = country, value = lifeExp)\ngapminder_sample_wide\n```\n\nSo the columns with the country names, `Australia`, `Canada`, and `United States` contain the `lifeExp` values corresponding to those countries for each year. Note that the `year` variable has been retained in the wide form. If you had tried to do this without the `year` variable in the data frame, you would run into an error that said `\"Error: Each row of output must be identified by a unique combination of keys.\"` Try running the following code. \n\n\n```{r eval = FALSE}\ngapminder_sample_long %>%\n  select(-year) %>%\n  spread(key = country, value = lifeExp)\n```\n\nThis is because when the year column is missing, there is no variable that tells purrr which values should go in the same rows together. This error message is a common source of frustration in tidyr, and Hadley has been working on replacements for `gather()` and `spread()` called `pivot_wider()` and `pivot_longer()`: https://tidyr.tidyverse.org/dev/articles/pivot.html. They haven't been incorporated into the CRAN versions of tidyr and the tidyverse yet though, but they probably will be soon. If you understand the principles of `gather()` and `spread()` then when the new pivot functions are introduced, it will be easy to learn how to use them.\n\nIf you wanted to go from the wide form to the long-form, you need to *gather* together the life expectancy values. This time, the `country` **key** and `lifeExp` **value** variable names do not currently exist in the data frame. The `key` and `value` arguments that you provide in the `gather()` function are what will be used as the names of the variables for the long-form version you're about to create. Just so you can see that these variables did not need to exist in the original data, you will call the key `country_var` and the value `lifeExp_var` (previously unused names).\n\n```{r}\ngapminder_sample_wide\ngapminder_sample_wide %>% \n  gather(key = country_var, value = lifeExp_var)\n```\n\n\nOh no.... something went wrong! The `year` variable has been included as a key (country). Since there is no distinction between the three country columns (`Australia`, `Canada`, and `United States`) and the `year` column, the `year` column was included in the gathering process. To exclude a column from the gathering process, you can explicitly remove it using e.g. `-year` as an argument to the gather function.\n\n\n```{r}\ngapminder_sample_wide %>% \n  gather(key = country_var, value = lifeExp_var, -year)\n```\n\n\n## Combining and separating variables\n\n\nThe `unite()` function combines columns into a single column. For instance, you can combine the country and year variables into a single variable, `countryyear`.\n\n```{r}\ngapminder_sample_united <- gapminder_sample_long %>%\n  unite(\"countryyear\", country, year, sep = \"_\")\ngapminder_sample_united\n```\n\nConversely, you can separate single columns into multiple columns. Below, I undo the `unite()` that I performed above using `separate()`. \n\n\n```{r}\ngapminder_sample_united %>%\n  separate(countryyear, c(\"country\", \"year\"), sep = \"_\")\n```\n\n\nTidyr also has some nice functions for dealing with missing values including \n\n- `drop_na()` that will remove every row that has a missing value (`NA`) in it.\n\n- `replace_na()` that will replace every missing value (`NA`) with whatever value you specify.\n\n\n\n\n# Replacing loops: purrr\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/purrr.jpg\")\n```\n\n\nIteration in the tidyverse is handled using `purrr`; a feline-friendly package for applying \"map\" functions (although it does a few other neat things too). If you are experienced in base R, then you're probably familiar with the `apply()` functions that can be used in place of loops for iteratively applying a function. The most common apply functions are \n\n`apply(matrix, margin, fun)` applies a function, `fun`, across each of the rows (if you set `margin = 1`) or each of the columns (if you set `margin = 2`) of a `matrix` (or array) and returns a vector.\n\n`sapply(object, fun)` applies a function, `fun`, to each entry of an `object` (which could be a vector, a data frame or a list), and usually returns a vector, but sometimes it returns a matrix, and often it is difficult to guess what type of object it will return before you run your code.\n\n`lapply(list, fun)` applies a function, `fun`, to each entry of a `list`, and returns a list. This one at least usually makes sense relative to the other apply functions.\n\nWhile there is nothing fundamentally wrong with the base R apply functions, the syntax is somewhat inconsistent across the different apply functions, and the expected type of the object they return is often ambiguous (at least it is for `sapply`...). Each of `purrr`'s map functions can be applied to vectors, lists and data frames. \n\nIt is useful to remember that a data frame is a special type of a list where each columns of the data frame corresponds to an entry of the list. Each entry of the data frame-list is a vector of the same length (although the vectors do not need to be of the same type). \n\nOne of the primary features of `purrr`'s map functions is that you need to specify the form of your output as a function suffix separated by an underscore. The first element is always the data object over which you want to iterate, and the second argument is always the function that you want to iteratively apply. For example:\n\n- `map(object, fun)` is the primary mapping function and returns a list\n\n- `map_df(object, fun)` returns a data frame\n\n- `map_dbl(object, fun)` returns a numeric (double) vector\n\n- `map_chr(object, fun)` returns a character vector\n\n- `map_lgl(object, fun)` returns a logical vector\n\n\n\nThe **input** to any `map` function is always either \n\n- a **vector** (of any type), in which case the iteration is done over the entries of the vector\n\n- a **list**, in which case the iteration is performed over the elements of the list\n\n- a **data frame**, in which case the iteration is performed over the columns of the data frame (which, since a data frame is a special kind of list, is technically the same as the previous point)\n\nThe **output** of each map function is specified by the term that follows the underscore in the function name. \n\n\n\nFundamentally, maps are for iteration. In the example below I will iterate through the vector `c(1, 4, 7)` by adding 10 to each entry. The following code is how you would do this using the base R apply functions\n\n\n```{r}\nlapply(c(1, 4, 7), function(number) {\n  return(number + 10)\n})\nsapply(c(1, 4, 7), function(number) {\n  return(number + 10)\n})\n```\n\nFor the `purrr` equivalents, if you want your output to be a list, you would use `map()`, if you want it to be a numeric vector, then you would use `map_dbl()`, if you want it to be a character, then it is `map_chr()`. \n\n\n```{r}\nlibrary(purrr)\nmap(c(1, 4, 7), function(number) {\n  return(number + 10)\n})\nmap_dbl(c(1, 4, 7), function(number) {\n  return(number + 10)\n})\nmap_chr(c(1, 4, 7), function(number) {\n  return(number + 10)\n})\n```\n\nIf you want to return a data frame, then you would use `map_df` (but you need to make sure that in each iteration you're returning a data frame which has consistent column names).\n\n```{r}\nmap_df(c(1, 4, 7), function(number) {\n  return(data.frame(old_number = number, \n                    new_number = number + 10))\n})\n```\n\n`map2` and `pmap` are versions of map functions that work over multiple data frames/lists/vectors at once. There are also fancy things that you can do with purrr that include iterating over entire lists of data as entries to columns of a tibble, but I won't talk about those here. My next blog post will be on purrr so keep a look out if you want to learn more. For a more comprehensive look at purrr, I recommend [Jenny Bryan's tutorial](https://jennybc.github.io/purrr-tutorial/). \n\n\n# Loading data: readr\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/readr.png\")\n```\n\n\nAt face-value, readr is probably the least exciting tidyverse package. At first glance, it mostly appears to offer tidyverse equivalents to the classic base R data loading functions such as `read.csv()`. Calling a readr data loading function is usually the same as the base R versions, *but* they use an underscore `_` separator rather than a period separator `.`, as in `read_csv()`. \n\nThe main advantages of the readr versions is that the data is read in directly as a **tibble**, and the readr loading functions do a much better job at deciding what *type* each variable should be (and it makes it easier to specify what types the columns should be at the time of loading if you have strong opinions). \n\nHowever, a closer look reveals that `readr` has some hidden talents that are sure to come in handy! For instance, readr has a series of `parse_` functions that convert abnormally represented data into normally represented data. For instance, `parse_number()` will extract the numeric component of strings with numbers in them. So if your collaborators give you a file with prices that have preceding \"\\$\"s or other characters in them, `parse_number()` will remove them for you without you having to do anything involving regular expressions.\n\n```{r}\nparse_number(c(\"$1,234.5\", \"$12.45\", \"99%\"))\n```\n\nTidyr can also be used to convert dates and times coded as strings to actual date-time formats. \n\n```{r}\nparse_datetime(\"2010-10-01 21:45\")\n```\n\nBut to be honest, I prefer to use the *lubridate* package for doing things with dates (see below).\n\nOkay, so maybe tidyr isn't the most exciting package, but that `parse_number()` thing is pretty neat!\n\n\n\n\n# Storing data: tibbles\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/tibble.png\")\n```\n\nTibbles are the tidyverse version of a data frame. You've probably used tibbles before without even realizing. They look and behave a LOT like a data frame. Often when you input a data frame to a tidyverse function, it comes out the other end as a tibble. The differences are minor and you're unlikely to notice them if you're just starting out, so I wouldn't worry about whether your data is stored as a data frame or a tibble. \n\nThe main differences that you might notice is in how they are printed to the console: tibbles are automatically truncated to 10 rows when printed into the console, and if you have too many variables, many of the variables are hidden from view. I secretly sometimes view my tibbles in the console using `as.data.frame(data)` so that it doesn't truncate. Probably a better thing to do would be to `View(data)`, but that opens a whole new window which I sometimes find kind of annoying. \n\nTibbles only become important much later down the tidyverse track when you want to use list columns to do fancy stuff with purrr.\n\n\n# Dates, factors and strings: lubridate, forcats and stringr\n\nWhile not technically a part of the tidyverse, there are also very useful packages for manipulating type-specific variables: lubridate for dates/times, forcats for factors and stringr for strings.\n\n## Handling dates and times: lubridate\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/lubridate.png\")\n```\n\nLubridate makes it really straightforward to deal with dates. One might say... it *lubricates* them... one might also not say that, because it's a bit weird. \n\nLubridate offers a simple way of converting dates/times stored as strings to dates/times stored as dates/times, and it makes it easy to do math with dates.\n\nThe primary set of functions are date-time-reading functions that convert strings to dates. To decide which function to use, you will need to figure out what format your dates are in (by... looking at them...). For instance, if your date is coded as `\"August 2nd 2019\"` or `\"08-05-19\"` or `\"08/02/19\"`, then you would use the `mdy()` function because it is coded as \"month-day-year\":\n\n```{r, warning=FALSE, message=FALSE}\nlibrary(lubridate)\nmdy(\"August 2nd 2019\")\nmdy(\"8-2-2019\")\nmdy(\"8/2/19\")\n```\n\nIf your dates were coded as \"year-month-day\" then you would use the `ymd()` function, and so on.\n\n\nStrings that contain times can be parsed using `hms()` for \"hour-minute-second\". \n\n```{r}\nhms(\"8:45:12\")\n```\n\nAnd date-times can be parsed using `ymd_hms()`, `ymd_hm()`, `ymd_h()`, as well as for the other date versions (`mdy_hms()`, `dmy_hms()`, etc...).\n\n```{r}\nmdy_hms(\"March 13th 2019 at 9:02:00\")\nmdy_hm(\"03-13-19, 9:02\")\n```\n\n\nYou can add fixed periods of time to dates easily using the `years()`, `months()`, `days()`, `hours()`, etc... functions. For instance:\n\n```{r}\nmdy(\"August 2nd 2019\") + days(42)\n```\n\nOnce your dates are in an actual date format, you can do intuitive mathematical calculations with date-times:\n\n\n```{r}\nmdy_hms(\"August 2nd 2019, 1:21:30 pm\") - mdy_hms(\"August 1st 2019, 11:23:33 am\")\n```\n\n\nPlus ggplot2 handles lubridate-dates really well.\n\n\n## Handling factors: forcats\n\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/forcats.png\")\n```\n\nFactors are somehow simultaneously very useful and the worst thing ever. Fortunately, since I discovered the `forcats` package, my factors have been on their best behaviour.\n\n\nThe forcats package has a few really useful functions. The ones I use most often are \n\n- `fct_inorder()` for reordering the levels of a factor so that the levels are in the order that they appear in the factor vector.\n\n- `fct_infreq()` for reordering the levels of a factor so that the levels are in order of most to least frequent.\n\n- `fct_rev()` for reversing the order of the levels of a factor.\n\n- `fct_relevel()` for manually reordering the levels of the factor.\n\n- `fct_reorder()` for reordering the levels based on their relationship to another variable.\n\nThere are other functions too, but I rarely use them. Check out the forcats [cheatsheet](file:///Users/Rebecca/Downloads/factors.pdf)!\n\n\n\nAn example of how the forcats package makes my life easier is when I want to reorder the factor levels. Factor levels are usually alphabetical by default, and I often want the factor levels to be in a specific order.\n\nAs an exercise both in ggplot2 and dplyr, I want to make a plot that shows the difference between life expectancy between 2007 and 1952 and arrange the countries in order of greatest difference in life expectancy. \n\n```{r}\ngapminder_life_exp_diff <- gapminder %>%\n  # filter to the starting and ending years only\n  filter(year == 1952 | year == 2007) %>%\n  # ensure that the data are arranged so that 1952 is first and 2007 is second \n  # within each year\n  arrange(country, year) %>%\n  # for country, add a variable corresponding to the difference between life \n  # expectency in 2007 and 1952\n  group_by(country) %>%\n  mutate(lifeExp_diff = lifeExp[2] - lifeExp[1],\n         # also calculate the largest population for the country (based on the two years)\n         max_pop = max(pop)) %>%\n  ungroup() %>%\n  # arrange in order of the biggest difference in life expectency\n  arrange(lifeExp_diff) %>%\n  # restrict to countries with a population of at least 30,000 so we can fit \n  # the plot in a reasonable space\n  filter(max_pop > 30000000) %>%\n  select(country, year, continent, lifeExp, lifeExp_diff)\ngapminder_life_exp_diff  \n```\n\nTo understand what the intermediate dplyr steps are doing in the code below, I suggest printing each step out to the console (without defining a new data frame) - i.e. first print `gapminder %>% filter(year == 1952 | year == 2007)`, then print `gapminder %>% filter(year == 1952 | year == 2007) %>% arrange(country, year)`, etc. \n\nThe next task is to make a dot plot that shows the life expectancy in 1952 and 2007 for each country. Since the countries in our data frame is arranged in order of smallest to biggest difference in life expectancy, one would expect that the plot will be too. However, the countries in the plot still appear in alphabetical order! The problem is that ggplot2 plots factors in order of their levels, but the `arrange()` dplyr function rearranges the order of the rows in the data frame but does not change the order of the factor levels.\n\n```{r, fig.align = \"center\"}\ngapminder_life_exp_diff %>%\n  ggplot() +\n  geom_point(aes(x = lifeExp, y = country, col = as.factor(year)))\n```\n\nIf I tried to fix this using base R, I would undoubtedly end up messing up which country is which. Fortunately this is really, really easy to fix using forcats! The `fct_inorder()` function will automatically reorder the levels of a factor in the order in which they appear in the vector.  So all I need to do is add one line of pre-processing code before I make my plot: `mutate(country = fct_inorder(country))`.\n\n\n```{r, fig.align = \"center\"}\ngapminder_life_exp_diff %>%\n  mutate(country = fct_inorder(country)) %>%\n  ggplot() +\n  geom_point(aes(x = lifeExp, y = country, col = as.factor(year)))\n```\n\n\nI'm a bit pedantic about data viz, so I can't leave this plot looking like this, so I'm just going to place some ggplot2 code here for making this plot waaaaay more badass. Try to read through the code and understand what its doing. This isn't a lesson in forcats, it's a lesson in EDA!\n\n\n```{r, fig.align = \"center\", fig.height = 10}\ngapminder_life_exp_diff %>%\n  mutate(country = fct_inorder(country)) %>%\n  # for each country define a varaible for min and max life expectancy\n  group_by(country) %>%\n  mutate(max_lifeExp = max(lifeExp),\n         min_lifeExp = min(lifeExp)) %>% \n  ungroup() %>%\n  ggplot() +\n  # plot a horizontal line from min to max life expectency for each country\n  geom_segment(aes(x = min_lifeExp, xend = max_lifeExp, \n                   y = country, yend = country,\n                   col = continent), alpha = 0.5, size = 7) +\n  # add a point for each life expectancy data point\n  geom_point(aes(x = lifeExp, y = country, col = continent), size = 8) +\n  # add text of the country name as well as the max and min life expectency \n  geom_text(aes(x = min_lifeExp + 0.7, y = country, \n                label = paste(country, round(min_lifeExp))), \n            col = \"grey50\", hjust = \"right\") +\n  geom_text(aes(x = max_lifeExp - 0.7, y = country, \n                label = round(max_lifeExp)), \n            col = \"grey50\", hjust = \"left\") +\n  # ensure that the left-most text is not cut off \n  scale_x_continuous(limits = c(20, 85)) +\n  # choose a different colour palette\n  scale_colour_brewer(palette = \"Pastel2\") +\n  # set the title\n  labs(title = \"Change in life expectancy\",\n       subtitle = \"Between 1952 and 2007\",\n       x = \"Life expectancy (in 1952 and 2007)\",\n       y = NULL, \n       col = \"Continent\") +\n  # remove the grey background\n  theme_classic() +\n  # remove the axes and move the legend to the top\n  theme(legend.position = \"top\", \n        axis.line = element_blank(),\n        axis.ticks = element_blank(),\n        axis.text = element_blank())\n```\n\n## Handling strings: stringr\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/stringr.jpg\")\n```\n\n\nR used to be terrible at handling strings. Stringr has made string-handling a LOT easier. The functions all start with `str_` and end with what you want to do to the string.\n\n\nFor instance, to return a logical that specifies whether a specific pattern exists in the string (the equivalent of `grepl()` in base R), you can use the `str_detect()` function\n\n```{r}\nstr_detect(\"I like bananas\", \"banana\")\n```\n\n\n\nMy friend Sara Stoudt [\\@sastoudt](https://twitter.com/sastoudt) wrote a wrote a very useful post for the tidyverse website comparing stringr with its Base R equivalents (https://stringr.tidyverse.org/articles/from-base.html). She provides the following useful table (hers is a bit longer - I'm just showing the parts I find most useful):\n\n| Action | Base R | Tidyverse |\n|--------------------------------|-------------------------|---------------------------|\n| Identify the location of a pattern | `gregexpr(pattern, x)` | \t`str_locate_all(x, pattern)` | \n| Keep strings matching a pattern | `grep(pattern, x, value = TRUE)` | `str_subset(x, pattern)` |\n| Identify position matching a pattern | `grep(pattern, x)` | `str_which(x, pattern)` |\n| Detect presence or absence of a pattern | `grepl(pattern, x)`\t| `str_detect(x, pattern)` |\n| Replace a pattern | `gsub(pattern, replacement, x)`\t| `str_replace_all(x, pattern, replacement)` |\n| Calculate the number of characters in a string | `nchar(x)` | `str_length(x)` |\n| Split a string into pieces | `strsplit(x, pattern)` | `str_split(x, pattern)` |\n| Extract a subset of a string | `substr(x, start, end)` | `str_sub(x, start, end)` | \n| Convert a string to lowercase | `tolower(x)` | `str_to_lower(x)` |\n| Convert a string to \"Title Case\" | `tools::toTitleCase(x)` | `str_to_title(x)` |\n| Convert a string to uppercase | `toupper(x)` | `str_to_upper(x)`|\n| Trim white space from a string | `trimws(x)` | `str_trim(x)` |\n\n\nIf you'd like to see a little more of stringr, check out Sara's post!","srcMarkdownNoYaml":"\n\n```{r echo = FALSE, fig.align = \"center\"}\nknitr::include_graphics(\"img/tidyverse/tidyverse_all.png\")\n```\n\nIf you're new to the tidyverse, I recommend that you first read [part one](http://www.rebeccabarter.com/blog/2019-08-05_base_r_to_tidyverse/) of this two-part series on transitioning into the tidyverse. Part 1 focuses on what I feel are the most important aspects and packages of the tidyverse: tidy thinking, piping, dplyr and ggplot2. \n\nThis second part of the two-part series focuses on the remaining (less essential, but still immensely useful) packages that make up the tidyverse: tidyr, purrr, readr, tibbles, as well as some additional type-specific packages (lubridate, forcats and stringr). Additional resources include the set of tidyverse [cheatsheets](https://www.rstudio.com/resources/cheatsheets/), as well as the [R for Data Science book](https://r4ds.had.co.nz/).\n\nStart by loading the tidyverse package into your environment.\n\n```{r, message=FALSE, warning=FALSE}\nlibrary(tidyverse)\n```\n\nThen load the gapminder data.\n\n\n```{r message=FALSE, warning=FALSE}\n# to download the data directly:\ngapminder_orig <- read.csv(\"https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder-FiveYearData.csv\")\n# define a copy of the original dataset that we will clean and play with \ngapminder <- gapminder_orig\n```\n\n\n# Data shaping: tidyr\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/tidyr.jpg\")\n```\n\nTidyr aims to help you reshape your data, and is very useful if you receive data in a format that isn't already \"tidy\". I also find myself using tidyr functions to help me calculate specific types of summaries and plots.\n\n\nFor instance, tidyr helps you convert your data between (a) long-form data where each variable is in a single column\n\n\n```{r echo = FALSE}\nlong <- gapminder %>%\n  filter(country %in% c(\"Australia\", \"United States\", \"Canada\"), year > 1990) %>%\n  select(country, year, lifeExp) \nlong \n```\n\nand (b) wide-form data where a single variable is separated into multiple columns based on some grouping (in this case, the life expectancy variable is separated into three columns, one for each country):\n\n```{r echo = FALSE}\nlong %>% mutate(country = paste0(country, \"_lifeExp\")) %>%\n  spread(key = country, \n                value = lifeExp) \n```\n\n\n## Gathering and spreading\n\nThe main tidyr functions are `spread()` and `gather()`. If you are familiar with the older reshape2 R package, you can think of tidyr as the tidyverse version, where `spread()` is the equivalent of `cast`, and `gather()` is the equivalent of `melt()`. If not... never mind!\n\nThink of `spread()` as a function that will spread a single variable's \"values\" across multiple columns based on a \"key\", or grouping variable. Similarly, think of `gather()` as a function that will gather a variable whose \"values\" are spread across multiple columns (where the \"key\" is the grouping variable that distinguishes the columns) into a single column. \n\nThe main things you need to figure out when using `spread()` and `gather()` are what are the \"key\" and what are the \"value\" columns of your data frame. If you are spreading your data (to make it wider), then your key and value variables are existing variables in the data. If you are gathering your data (making it longer), then you will need to define key and value variables that will become variable names in your long-form data frame. \n\nBelow I'll show how this works with a small subset of the gapminder dataset, corresponding to the life expectancy for US, Australia, and Canada for each year in the data after 1990. \n\n\nSuppose that you started with the long-form data.\n\n```{r}\ngapminder_sample_long <- gapminder %>%\n  filter(country %in% c(\"Australia\", \"United States\", \"Canada\"), year > 1990) %>%\n  select(country, year, lifeExp) \ngapminder_sample_long\n``` \n\nA wide-form version might have the life expectancy variable *spread* into three variables, one for each country (it would also be perfectly feasible to separate by year). So in this case, the **value** that you want to spread is the `lifeExp` variable, and the **key** that you want to spread/group by is the `country` variable.\n\n```{r}\ngapminder_sample_wide <- gapminder_sample_long %>% \n  spread(key = country, value = lifeExp)\ngapminder_sample_wide\n```\n\nSo the columns with the country names, `Australia`, `Canada`, and `United States` contain the `lifeExp` values corresponding to those countries for each year. Note that the `year` variable has been retained in the wide form. If you had tried to do this without the `year` variable in the data frame, you would run into an error that said `\"Error: Each row of output must be identified by a unique combination of keys.\"` Try running the following code. \n\n\n```{r eval = FALSE}\ngapminder_sample_long %>%\n  select(-year) %>%\n  spread(key = country, value = lifeExp)\n```\n\nThis is because when the year column is missing, there is no variable that tells purrr which values should go in the same rows together. This error message is a common source of frustration in tidyr, and Hadley has been working on replacements for `gather()` and `spread()` called `pivot_wider()` and `pivot_longer()`: https://tidyr.tidyverse.org/dev/articles/pivot.html. They haven't been incorporated into the CRAN versions of tidyr and the tidyverse yet though, but they probably will be soon. If you understand the principles of `gather()` and `spread()` then when the new pivot functions are introduced, it will be easy to learn how to use them.\n\nIf you wanted to go from the wide form to the long-form, you need to *gather* together the life expectancy values. This time, the `country` **key** and `lifeExp` **value** variable names do not currently exist in the data frame. The `key` and `value` arguments that you provide in the `gather()` function are what will be used as the names of the variables for the long-form version you're about to create. Just so you can see that these variables did not need to exist in the original data, you will call the key `country_var` and the value `lifeExp_var` (previously unused names).\n\n```{r}\ngapminder_sample_wide\ngapminder_sample_wide %>% \n  gather(key = country_var, value = lifeExp_var)\n```\n\n\nOh no.... something went wrong! The `year` variable has been included as a key (country). Since there is no distinction between the three country columns (`Australia`, `Canada`, and `United States`) and the `year` column, the `year` column was included in the gathering process. To exclude a column from the gathering process, you can explicitly remove it using e.g. `-year` as an argument to the gather function.\n\n\n```{r}\ngapminder_sample_wide %>% \n  gather(key = country_var, value = lifeExp_var, -year)\n```\n\n\n## Combining and separating variables\n\n\nThe `unite()` function combines columns into a single column. For instance, you can combine the country and year variables into a single variable, `countryyear`.\n\n```{r}\ngapminder_sample_united <- gapminder_sample_long %>%\n  unite(\"countryyear\", country, year, sep = \"_\")\ngapminder_sample_united\n```\n\nConversely, you can separate single columns into multiple columns. Below, I undo the `unite()` that I performed above using `separate()`. \n\n\n```{r}\ngapminder_sample_united %>%\n  separate(countryyear, c(\"country\", \"year\"), sep = \"_\")\n```\n\n\nTidyr also has some nice functions for dealing with missing values including \n\n- `drop_na()` that will remove every row that has a missing value (`NA`) in it.\n\n- `replace_na()` that will replace every missing value (`NA`) with whatever value you specify.\n\n\n\n\n# Replacing loops: purrr\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/purrr.jpg\")\n```\n\n\nIteration in the tidyverse is handled using `purrr`; a feline-friendly package for applying \"map\" functions (although it does a few other neat things too). If you are experienced in base R, then you're probably familiar with the `apply()` functions that can be used in place of loops for iteratively applying a function. The most common apply functions are \n\n`apply(matrix, margin, fun)` applies a function, `fun`, across each of the rows (if you set `margin = 1`) or each of the columns (if you set `margin = 2`) of a `matrix` (or array) and returns a vector.\n\n`sapply(object, fun)` applies a function, `fun`, to each entry of an `object` (which could be a vector, a data frame or a list), and usually returns a vector, but sometimes it returns a matrix, and often it is difficult to guess what type of object it will return before you run your code.\n\n`lapply(list, fun)` applies a function, `fun`, to each entry of a `list`, and returns a list. This one at least usually makes sense relative to the other apply functions.\n\nWhile there is nothing fundamentally wrong with the base R apply functions, the syntax is somewhat inconsistent across the different apply functions, and the expected type of the object they return is often ambiguous (at least it is for `sapply`...). Each of `purrr`'s map functions can be applied to vectors, lists and data frames. \n\nIt is useful to remember that a data frame is a special type of a list where each columns of the data frame corresponds to an entry of the list. Each entry of the data frame-list is a vector of the same length (although the vectors do not need to be of the same type). \n\nOne of the primary features of `purrr`'s map functions is that you need to specify the form of your output as a function suffix separated by an underscore. The first element is always the data object over which you want to iterate, and the second argument is always the function that you want to iteratively apply. For example:\n\n- `map(object, fun)` is the primary mapping function and returns a list\n\n- `map_df(object, fun)` returns a data frame\n\n- `map_dbl(object, fun)` returns a numeric (double) vector\n\n- `map_chr(object, fun)` returns a character vector\n\n- `map_lgl(object, fun)` returns a logical vector\n\n\n\nThe **input** to any `map` function is always either \n\n- a **vector** (of any type), in which case the iteration is done over the entries of the vector\n\n- a **list**, in which case the iteration is performed over the elements of the list\n\n- a **data frame**, in which case the iteration is performed over the columns of the data frame (which, since a data frame is a special kind of list, is technically the same as the previous point)\n\nThe **output** of each map function is specified by the term that follows the underscore in the function name. \n\n\n\nFundamentally, maps are for iteration. In the example below I will iterate through the vector `c(1, 4, 7)` by adding 10 to each entry. The following code is how you would do this using the base R apply functions\n\n\n```{r}\nlapply(c(1, 4, 7), function(number) {\n  return(number + 10)\n})\nsapply(c(1, 4, 7), function(number) {\n  return(number + 10)\n})\n```\n\nFor the `purrr` equivalents, if you want your output to be a list, you would use `map()`, if you want it to be a numeric vector, then you would use `map_dbl()`, if you want it to be a character, then it is `map_chr()`. \n\n\n```{r}\nlibrary(purrr)\nmap(c(1, 4, 7), function(number) {\n  return(number + 10)\n})\nmap_dbl(c(1, 4, 7), function(number) {\n  return(number + 10)\n})\nmap_chr(c(1, 4, 7), function(number) {\n  return(number + 10)\n})\n```\n\nIf you want to return a data frame, then you would use `map_df` (but you need to make sure that in each iteration you're returning a data frame which has consistent column names).\n\n```{r}\nmap_df(c(1, 4, 7), function(number) {\n  return(data.frame(old_number = number, \n                    new_number = number + 10))\n})\n```\n\n`map2` and `pmap` are versions of map functions that work over multiple data frames/lists/vectors at once. There are also fancy things that you can do with purrr that include iterating over entire lists of data as entries to columns of a tibble, but I won't talk about those here. My next blog post will be on purrr so keep a look out if you want to learn more. For a more comprehensive look at purrr, I recommend [Jenny Bryan's tutorial](https://jennybc.github.io/purrr-tutorial/). \n\n\n# Loading data: readr\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/readr.png\")\n```\n\n\nAt face-value, readr is probably the least exciting tidyverse package. At first glance, it mostly appears to offer tidyverse equivalents to the classic base R data loading functions such as `read.csv()`. Calling a readr data loading function is usually the same as the base R versions, *but* they use an underscore `_` separator rather than a period separator `.`, as in `read_csv()`. \n\nThe main advantages of the readr versions is that the data is read in directly as a **tibble**, and the readr loading functions do a much better job at deciding what *type* each variable should be (and it makes it easier to specify what types the columns should be at the time of loading if you have strong opinions). \n\nHowever, a closer look reveals that `readr` has some hidden talents that are sure to come in handy! For instance, readr has a series of `parse_` functions that convert abnormally represented data into normally represented data. For instance, `parse_number()` will extract the numeric component of strings with numbers in them. So if your collaborators give you a file with prices that have preceding \"\\$\"s or other characters in them, `parse_number()` will remove them for you without you having to do anything involving regular expressions.\n\n```{r}\nparse_number(c(\"$1,234.5\", \"$12.45\", \"99%\"))\n```\n\nTidyr can also be used to convert dates and times coded as strings to actual date-time formats. \n\n```{r}\nparse_datetime(\"2010-10-01 21:45\")\n```\n\nBut to be honest, I prefer to use the *lubridate* package for doing things with dates (see below).\n\nOkay, so maybe tidyr isn't the most exciting package, but that `parse_number()` thing is pretty neat!\n\n\n\n\n# Storing data: tibbles\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/tibble.png\")\n```\n\nTibbles are the tidyverse version of a data frame. You've probably used tibbles before without even realizing. They look and behave a LOT like a data frame. Often when you input a data frame to a tidyverse function, it comes out the other end as a tibble. The differences are minor and you're unlikely to notice them if you're just starting out, so I wouldn't worry about whether your data is stored as a data frame or a tibble. \n\nThe main differences that you might notice is in how they are printed to the console: tibbles are automatically truncated to 10 rows when printed into the console, and if you have too many variables, many of the variables are hidden from view. I secretly sometimes view my tibbles in the console using `as.data.frame(data)` so that it doesn't truncate. Probably a better thing to do would be to `View(data)`, but that opens a whole new window which I sometimes find kind of annoying. \n\nTibbles only become important much later down the tidyverse track when you want to use list columns to do fancy stuff with purrr.\n\n\n# Dates, factors and strings: lubridate, forcats and stringr\n\nWhile not technically a part of the tidyverse, there are also very useful packages for manipulating type-specific variables: lubridate for dates/times, forcats for factors and stringr for strings.\n\n## Handling dates and times: lubridate\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/lubridate.png\")\n```\n\nLubridate makes it really straightforward to deal with dates. One might say... it *lubricates* them... one might also not say that, because it's a bit weird. \n\nLubridate offers a simple way of converting dates/times stored as strings to dates/times stored as dates/times, and it makes it easy to do math with dates.\n\nThe primary set of functions are date-time-reading functions that convert strings to dates. To decide which function to use, you will need to figure out what format your dates are in (by... looking at them...). For instance, if your date is coded as `\"August 2nd 2019\"` or `\"08-05-19\"` or `\"08/02/19\"`, then you would use the `mdy()` function because it is coded as \"month-day-year\":\n\n```{r, warning=FALSE, message=FALSE}\nlibrary(lubridate)\nmdy(\"August 2nd 2019\")\nmdy(\"8-2-2019\")\nmdy(\"8/2/19\")\n```\n\nIf your dates were coded as \"year-month-day\" then you would use the `ymd()` function, and so on.\n\n\nStrings that contain times can be parsed using `hms()` for \"hour-minute-second\". \n\n```{r}\nhms(\"8:45:12\")\n```\n\nAnd date-times can be parsed using `ymd_hms()`, `ymd_hm()`, `ymd_h()`, as well as for the other date versions (`mdy_hms()`, `dmy_hms()`, etc...).\n\n```{r}\nmdy_hms(\"March 13th 2019 at 9:02:00\")\nmdy_hm(\"03-13-19, 9:02\")\n```\n\n\nYou can add fixed periods of time to dates easily using the `years()`, `months()`, `days()`, `hours()`, etc... functions. For instance:\n\n```{r}\nmdy(\"August 2nd 2019\") + days(42)\n```\n\nOnce your dates are in an actual date format, you can do intuitive mathematical calculations with date-times:\n\n\n```{r}\nmdy_hms(\"August 2nd 2019, 1:21:30 pm\") - mdy_hms(\"August 1st 2019, 11:23:33 am\")\n```\n\n\nPlus ggplot2 handles lubridate-dates really well.\n\n\n## Handling factors: forcats\n\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/forcats.png\")\n```\n\nFactors are somehow simultaneously very useful and the worst thing ever. Fortunately, since I discovered the `forcats` package, my factors have been on their best behaviour.\n\n\nThe forcats package has a few really useful functions. The ones I use most often are \n\n- `fct_inorder()` for reordering the levels of a factor so that the levels are in the order that they appear in the factor vector.\n\n- `fct_infreq()` for reordering the levels of a factor so that the levels are in order of most to least frequent.\n\n- `fct_rev()` for reversing the order of the levels of a factor.\n\n- `fct_relevel()` for manually reordering the levels of the factor.\n\n- `fct_reorder()` for reordering the levels based on their relationship to another variable.\n\nThere are other functions too, but I rarely use them. Check out the forcats [cheatsheet](file:///Users/Rebecca/Downloads/factors.pdf)!\n\n\n\nAn example of how the forcats package makes my life easier is when I want to reorder the factor levels. Factor levels are usually alphabetical by default, and I often want the factor levels to be in a specific order.\n\nAs an exercise both in ggplot2 and dplyr, I want to make a plot that shows the difference between life expectancy between 2007 and 1952 and arrange the countries in order of greatest difference in life expectancy. \n\n```{r}\ngapminder_life_exp_diff <- gapminder %>%\n  # filter to the starting and ending years only\n  filter(year == 1952 | year == 2007) %>%\n  # ensure that the data are arranged so that 1952 is first and 2007 is second \n  # within each year\n  arrange(country, year) %>%\n  # for country, add a variable corresponding to the difference between life \n  # expectency in 2007 and 1952\n  group_by(country) %>%\n  mutate(lifeExp_diff = lifeExp[2] - lifeExp[1],\n         # also calculate the largest population for the country (based on the two years)\n         max_pop = max(pop)) %>%\n  ungroup() %>%\n  # arrange in order of the biggest difference in life expectency\n  arrange(lifeExp_diff) %>%\n  # restrict to countries with a population of at least 30,000 so we can fit \n  # the plot in a reasonable space\n  filter(max_pop > 30000000) %>%\n  select(country, year, continent, lifeExp, lifeExp_diff)\ngapminder_life_exp_diff  \n```\n\nTo understand what the intermediate dplyr steps are doing in the code below, I suggest printing each step out to the console (without defining a new data frame) - i.e. first print `gapminder %>% filter(year == 1952 | year == 2007)`, then print `gapminder %>% filter(year == 1952 | year == 2007) %>% arrange(country, year)`, etc. \n\nThe next task is to make a dot plot that shows the life expectancy in 1952 and 2007 for each country. Since the countries in our data frame is arranged in order of smallest to biggest difference in life expectancy, one would expect that the plot will be too. However, the countries in the plot still appear in alphabetical order! The problem is that ggplot2 plots factors in order of their levels, but the `arrange()` dplyr function rearranges the order of the rows in the data frame but does not change the order of the factor levels.\n\n```{r, fig.align = \"center\"}\ngapminder_life_exp_diff %>%\n  ggplot() +\n  geom_point(aes(x = lifeExp, y = country, col = as.factor(year)))\n```\n\nIf I tried to fix this using base R, I would undoubtedly end up messing up which country is which. Fortunately this is really, really easy to fix using forcats! The `fct_inorder()` function will automatically reorder the levels of a factor in the order in which they appear in the vector.  So all I need to do is add one line of pre-processing code before I make my plot: `mutate(country = fct_inorder(country))`.\n\n\n```{r, fig.align = \"center\"}\ngapminder_life_exp_diff %>%\n  mutate(country = fct_inorder(country)) %>%\n  ggplot() +\n  geom_point(aes(x = lifeExp, y = country, col = as.factor(year)))\n```\n\n\nI'm a bit pedantic about data viz, so I can't leave this plot looking like this, so I'm just going to place some ggplot2 code here for making this plot waaaaay more badass. Try to read through the code and understand what its doing. This isn't a lesson in forcats, it's a lesson in EDA!\n\n\n```{r, fig.align = \"center\", fig.height = 10}\ngapminder_life_exp_diff %>%\n  mutate(country = fct_inorder(country)) %>%\n  # for each country define a varaible for min and max life expectancy\n  group_by(country) %>%\n  mutate(max_lifeExp = max(lifeExp),\n         min_lifeExp = min(lifeExp)) %>% \n  ungroup() %>%\n  ggplot() +\n  # plot a horizontal line from min to max life expectency for each country\n  geom_segment(aes(x = min_lifeExp, xend = max_lifeExp, \n                   y = country, yend = country,\n                   col = continent), alpha = 0.5, size = 7) +\n  # add a point for each life expectancy data point\n  geom_point(aes(x = lifeExp, y = country, col = continent), size = 8) +\n  # add text of the country name as well as the max and min life expectency \n  geom_text(aes(x = min_lifeExp + 0.7, y = country, \n                label = paste(country, round(min_lifeExp))), \n            col = \"grey50\", hjust = \"right\") +\n  geom_text(aes(x = max_lifeExp - 0.7, y = country, \n                label = round(max_lifeExp)), \n            col = \"grey50\", hjust = \"left\") +\n  # ensure that the left-most text is not cut off \n  scale_x_continuous(limits = c(20, 85)) +\n  # choose a different colour palette\n  scale_colour_brewer(palette = \"Pastel2\") +\n  # set the title\n  labs(title = \"Change in life expectancy\",\n       subtitle = \"Between 1952 and 2007\",\n       x = \"Life expectancy (in 1952 and 2007)\",\n       y = NULL, \n       col = \"Continent\") +\n  # remove the grey background\n  theme_classic() +\n  # remove the axes and move the legend to the top\n  theme(legend.position = \"top\", \n        axis.line = element_blank(),\n        axis.ticks = element_blank(),\n        axis.text = element_blank())\n```\n\n## Handling strings: stringr\n\n```{r echo = FALSE, fig.align = \"center\", out.height=\"200px\", out.width=\"180px\"}\nknitr::include_graphics(\"img/tidyverse/stringr.jpg\")\n```\n\n\nR used to be terrible at handling strings. Stringr has made string-handling a LOT easier. The functions all start with `str_` and end with what you want to do to the string.\n\n\nFor instance, to return a logical that specifies whether a specific pattern exists in the string (the equivalent of `grepl()` in base R), you can use the `str_detect()` function\n\n```{r}\nstr_detect(\"I like bananas\", \"banana\")\n```\n\n\n\nMy friend Sara Stoudt [\\@sastoudt](https://twitter.com/sastoudt) wrote a wrote a very useful post for the tidyverse website comparing stringr with its Base R equivalents (https://stringr.tidyverse.org/articles/from-base.html). She provides the following useful table (hers is a bit longer - I'm just showing the parts I find most useful):\n\n| Action | Base R | Tidyverse |\n|--------------------------------|-------------------------|---------------------------|\n| Identify the location of a pattern | `gregexpr(pattern, x)` | \t`str_locate_all(x, pattern)` | \n| Keep strings matching a pattern | `grep(pattern, x, value = TRUE)` | `str_subset(x, pattern)` |\n| Identify position matching a pattern | `grep(pattern, x)` | `str_which(x, pattern)` |\n| Detect presence or absence of a pattern | `grepl(pattern, x)`\t| `str_detect(x, pattern)` |\n| Replace a pattern | `gsub(pattern, replacement, x)`\t| `str_replace_all(x, pattern, replacement)` |\n| Calculate the number of characters in a string | `nchar(x)` | `str_length(x)` |\n| Split a string into pieces | `strsplit(x, pattern)` | `str_split(x, pattern)` |\n| Extract a subset of a string | `substr(x, start, end)` | `str_sub(x, start, end)` | \n| Convert a string to lowercase | `tolower(x)` | `str_to_lower(x)` |\n| Convert a string to \"Title Case\" | `tools::toTitleCase(x)` | `str_to_title(x)` |\n| Convert a string to uppercase | `toupper(x)` | `str_to_upper(x)`|\n| Trim white space from a string | `trimws(x)` | `str_trim(x)` |\n\n\nIf you'd like to see a little more of stringr, check out Sara's post!"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"2019-08-05_base_r_to_tidyverse_pt2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","theme":"simplex","linkcolor":"#6633c4","code-copy":true,"footnotes-hover":true,"title-block-banner":true,"comments":{"utterances":{"repo":"rlbarter/blog_comments"}},"title":"Transitioning into the tidyverse (part 2)","author":"Rebecca Barter","categories":["R","tidyverse","tidyr","purrr","readr","tibbles","lubridate","forcats","stringr"],"date":"2019-08-05","description":"This post walks through what base R users need to know for their transition into the tidyverse. Part 2 focuses on the more specialized R packages tidyr, purrr, readr, lubridate, forcats, etc","toc-location":"left"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}