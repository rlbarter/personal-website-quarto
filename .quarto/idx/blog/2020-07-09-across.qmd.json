{"title":"Across (dplyr 1.0.0): applying dplyr functions simultaneously across multiple columns","markdown":{"yaml":{"title":"Across (dplyr 1.0.0): applying dplyr functions simultaneously across multiple columns","author":"Rebecca Barter","format":{"html":{"toc":true,"toc-location":"left"}},"categories":["R","tidyverse","dplyr"],"date":"2020-07-09","description":"With the introduction of dplyr 1.0.0, there are a few new features: the biggest of which is across() which supersedes the scoped versions of dplyr functions."},"headingText":"remotes::install_github(\"allisonhorst/palmerpenguins\")","containsRefs":false,"markdown":"\n\nI often find that I want to use a dplyr function on multiple columns at once. For instance, perhaps I want to scale all of the numeric variables at once using a mutate function, or I want to provide the same summary for three of my variables.\n\nWhile it's been possible to do such tasks for a while using [scoped verbs](http://www.rebeccabarter.com/blog/2019-01-23_scoped-verbs/), it's now even easier - and more consistent - using dplyr's new `across()` function.\n\n\nTo demonstrate `across()`, I'm going to use Palmer's Penguin dataset, which was originally collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER, but has recently been made popular in the R community by [Allison Horst](https://twitter.com/allison_horst) as an alternative to the over-used Iris dataset.\n\nTo start with, let's load the penguins dataset (via the `palmerpenguins` package) and the tidyverse package. If you're new to the tidyverse (primarily to dplyr and piping, `%>%`), I suggest taking a look at [my post on the tidyverse](http://www.rebeccabarter.com/blog/2019-08-05_base_r_to_tidyverse/) before reading this post.\n\n```{r warning=FALSE, message=FALSE}\nlibrary(palmerpenguins)\nlibrary(tidyverse)\n```\n\n\n```{r}\npenguins\n```\n\nThere are 344 rows in the penguins dataset, one for each penguin, and 7 columns. The first two columns, `species` and `island`, specify the species and island of the penguin, the next four specify numeric traits about the penguin, including the bill and flipper length, the bill depth and the body mass.\n\n\nThe new `across()` function turns all dplyr functions into \"scoped\" versions of themselves, which means you can specify multiple columns that your dplyr function will apply to.\n\nOrdinarily, if we want to `summarise` a single column, such as `species`, by calculating the number of distinct entries (using `n_distinct()`) it contains, we would typically write\n\n```{r}\npenguins %>%\n  summarise(distinct_species = n_distinct(species))\n```\n\nIf we wanted to calculate `n_distinct()` not only across `species`, but also across `island` and `sex`, we would need to write out the `n_distinct` function three separate times:\n\n\n```{r}\npenguins %>%\n  summarise(distinct_species = n_distinct(species),\n            distinct_island = n_distinct(island),\n            distinct_sex = n_distinct(sex))\n```\n\nWouldn't it be nice if we could just write which columns we want to apply `n_distinct()` to, and then specify `n_distinct()` once, rather than having to apply n_distinct to each column separately? \n\nThis is where `across()` comes in. It is used *inside* your favourite dplyr function and the syntax is `across(.cols, .fnd)`, where `.cols` specifies the columns that you want the dplyr function to act on. When dplyr functions involve external functions that you're applying to columns e.g. `n_distinct()` in the example above, this external function is placed in the `.fnd` argument. For example, we would to apply `n_distinct()` to `species`, `island`, and `sex`, we would write `across(c(species, island, sex), n_distinct)` in the `summarise` parentheses.\n\n\nNote that we are specifying which variables we want to involve in the `summarise` using `c()`, as if we're listing the variable names in a vector, but because we're in dplyr-land, we don't need to put them in quotes:\n\n```{r}\npenguins %>%\n  summarise(across(c(species, island, sex), \n                   n_distinct))\n```\n\nSomething else that's really neat is that you can also use `!c()` to negate a set of variables (i.e. to apply the function to all variables *except* those that you specified in `c()`):\n\n\n```{r}\npenguins %>%\n  summarise(across(!c(species, island, sex), \n                   n_distinct))\n```\n\n\nI want to emphasize here that the function `n_distinct()` *is an argument of `across()`*, rather than being an argument of the dplyr function (`summarise`).\n\n\n# Select helpers: selecting columns to apply the function to\n\nSo far we've seen how to apply a dplyr function to a set of columns using a vector notation `c(col1, col2, col3, ...)`. However, there are many other ways to specify the columns that you want to apply the dplyr function to.\n\n\n- `everything()`: apply the function to all of the columns\n\n\n```{r}\npenguins %>%\n  summarise(across(everything(), n_distinct))\n```\n\n\n- `starts_with()`: apply the function to all columns whose name starts with a specific string\n\n\n```{r}\npenguins %>%\n  summarise(across(starts_with(\"bill\"), n_distinct))\n```\n\n\n- `contains()`: apply the function to all columns whose name contains a specific string\n\n```{r}\npenguins %>%\n  summarise(across(contains(\"length\"), n_distinct))\n```\n\n- `where()` apply the function to all columns that satisfy a logical condition, such as `is.numeric()`\n\n```{r}\npenguins %>%\n  summarise(across(where(is.numeric), n_distinct))\n```\n\n\nThe full list of select helpers can be found [here](https://dplyr.tidyverse.org/reference/select.html).\n\n\n\n# Using in-line functions with across\n\nLet's look at an example of summarizing the columns using a custom function (rather than `n_distinct()`). I usually do this using the tilde-dot shorthand for inline functions. The notation works by replacing\n\n```{r eval = FALSE}\nfunction(x) {\n  x + 10\n}\n```\n\nwith \n\n```{r eval = FALSE}\n~{.x + 10}\n```\n\n`~` indicates that you have started an anonymous function, and the argument of the anonymous function can be referred to using `.x` (or simply `.`). Unlike normal function arguments that can be anything that you like, the tilde-dot function argument is always `.x`.\n\nFor instance, to identify how many missing values there are in every column, we could specify the inline function `~sum(is.na(.))`, which calculates how many `NA` values are in each column (where the column is represented by `.`) and adds them up:\n\n```{r}\npenguins %>%\n  summarise(across(everything(), \n                   ~sum(is.na(.))))\n```\n\n\nThis shows that there are missing values in every column except for the first two (`species` and `island`).\n\n\n# A mutate example\n\nWhat if we want to replace the missing values in the numeric columns with 0 (clearly a terrible choice)? Without the `across()` function, we would apply an `if_else()` function separately to each numeric column, which will replace all `NA` values with 0 and leave all non-`NA` values as they are:\n\n```{r}\nreplace0 <- function(x) {\n  if_else(condition = is.na(x), \n          true = 0, \n          false = as.numeric(x))\n}\npenguins %>%\n  mutate(bill_length_mm = replace0(bill_length_mm),\n         bill_depth_mm = replace0(bill_depth_mm),\n         flipper_length_mm = replace0(flipper_length_mm),\n         body_mass_g = replace0(body_mass_g))\n```\n\n\nBut fortunately, we can do this a lot more efficiently with `across()`.\n\n\n\n```{r}\n# define a function to replace NA with 0\n\npenguins %>%\n  mutate(across(where(is.numeric), replace0))\n```\n\n\nAlthough obviously 0 isn't a great choice, so perhaps we can replace the missing values with the mean value of the column. This time, rather than define a new function (in place of `replace0`), we'll be a bit more concise and use the tilde-dot notation to specify the function we want to apply.\n\n```{r}\npenguins %>%\n  mutate(across(where(is.numeric), ~if_else(is.na(.), mean(., na.rm = T), as.numeric(.))))\n```\n\nOr better yet, perhaps we can replace the missing values with the average value within the relevant species and island.\n\n```{r}\npenguins %>%\n  group_by(species, island) %>%\n  mutate(across(where(is.numeric), \n                ~if_else(condition = is.na(.), \n                         true = mean(., na.rm = T), \n                         false = as.numeric(.)))) %>%\n  ungroup()\n```\n\n# A select example\n\nWhen you're using select, you don't have to include the `across()` function, because the select helpers have always worked with `select()`. This means that you can just write\n\n```{r}\npenguins %>%\n  select(where(is.numeric))\n```\n\nrather than\n\n```{r, eval = FALSE}\npenguins %>%\n  select(across(where(is.numeric)))\n```\n\nwhich will throw an error.\n\n\nHopefully `across()` will make your life easier, as it has mine!\n","srcMarkdownNoYaml":"\n\nI often find that I want to use a dplyr function on multiple columns at once. For instance, perhaps I want to scale all of the numeric variables at once using a mutate function, or I want to provide the same summary for three of my variables.\n\nWhile it's been possible to do such tasks for a while using [scoped verbs](http://www.rebeccabarter.com/blog/2019-01-23_scoped-verbs/), it's now even easier - and more consistent - using dplyr's new `across()` function.\n\n\nTo demonstrate `across()`, I'm going to use Palmer's Penguin dataset, which was originally collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER, but has recently been made popular in the R community by [Allison Horst](https://twitter.com/allison_horst) as an alternative to the over-used Iris dataset.\n\nTo start with, let's load the penguins dataset (via the `palmerpenguins` package) and the tidyverse package. If you're new to the tidyverse (primarily to dplyr and piping, `%>%`), I suggest taking a look at [my post on the tidyverse](http://www.rebeccabarter.com/blog/2019-08-05_base_r_to_tidyverse/) before reading this post.\n\n```{r warning=FALSE, message=FALSE}\n# remotes::install_github(\"allisonhorst/palmerpenguins\")\nlibrary(palmerpenguins)\nlibrary(tidyverse)\n```\n\n\n```{r}\npenguins\n```\n\nThere are 344 rows in the penguins dataset, one for each penguin, and 7 columns. The first two columns, `species` and `island`, specify the species and island of the penguin, the next four specify numeric traits about the penguin, including the bill and flipper length, the bill depth and the body mass.\n\n\nThe new `across()` function turns all dplyr functions into \"scoped\" versions of themselves, which means you can specify multiple columns that your dplyr function will apply to.\n\nOrdinarily, if we want to `summarise` a single column, such as `species`, by calculating the number of distinct entries (using `n_distinct()`) it contains, we would typically write\n\n```{r}\npenguins %>%\n  summarise(distinct_species = n_distinct(species))\n```\n\nIf we wanted to calculate `n_distinct()` not only across `species`, but also across `island` and `sex`, we would need to write out the `n_distinct` function three separate times:\n\n\n```{r}\npenguins %>%\n  summarise(distinct_species = n_distinct(species),\n            distinct_island = n_distinct(island),\n            distinct_sex = n_distinct(sex))\n```\n\nWouldn't it be nice if we could just write which columns we want to apply `n_distinct()` to, and then specify `n_distinct()` once, rather than having to apply n_distinct to each column separately? \n\nThis is where `across()` comes in. It is used *inside* your favourite dplyr function and the syntax is `across(.cols, .fnd)`, where `.cols` specifies the columns that you want the dplyr function to act on. When dplyr functions involve external functions that you're applying to columns e.g. `n_distinct()` in the example above, this external function is placed in the `.fnd` argument. For example, we would to apply `n_distinct()` to `species`, `island`, and `sex`, we would write `across(c(species, island, sex), n_distinct)` in the `summarise` parentheses.\n\n\nNote that we are specifying which variables we want to involve in the `summarise` using `c()`, as if we're listing the variable names in a vector, but because we're in dplyr-land, we don't need to put them in quotes:\n\n```{r}\npenguins %>%\n  summarise(across(c(species, island, sex), \n                   n_distinct))\n```\n\nSomething else that's really neat is that you can also use `!c()` to negate a set of variables (i.e. to apply the function to all variables *except* those that you specified in `c()`):\n\n\n```{r}\npenguins %>%\n  summarise(across(!c(species, island, sex), \n                   n_distinct))\n```\n\n\nI want to emphasize here that the function `n_distinct()` *is an argument of `across()`*, rather than being an argument of the dplyr function (`summarise`).\n\n\n# Select helpers: selecting columns to apply the function to\n\nSo far we've seen how to apply a dplyr function to a set of columns using a vector notation `c(col1, col2, col3, ...)`. However, there are many other ways to specify the columns that you want to apply the dplyr function to.\n\n\n- `everything()`: apply the function to all of the columns\n\n\n```{r}\npenguins %>%\n  summarise(across(everything(), n_distinct))\n```\n\n\n- `starts_with()`: apply the function to all columns whose name starts with a specific string\n\n\n```{r}\npenguins %>%\n  summarise(across(starts_with(\"bill\"), n_distinct))\n```\n\n\n- `contains()`: apply the function to all columns whose name contains a specific string\n\n```{r}\npenguins %>%\n  summarise(across(contains(\"length\"), n_distinct))\n```\n\n- `where()` apply the function to all columns that satisfy a logical condition, such as `is.numeric()`\n\n```{r}\npenguins %>%\n  summarise(across(where(is.numeric), n_distinct))\n```\n\n\nThe full list of select helpers can be found [here](https://dplyr.tidyverse.org/reference/select.html).\n\n\n\n# Using in-line functions with across\n\nLet's look at an example of summarizing the columns using a custom function (rather than `n_distinct()`). I usually do this using the tilde-dot shorthand for inline functions. The notation works by replacing\n\n```{r eval = FALSE}\nfunction(x) {\n  x + 10\n}\n```\n\nwith \n\n```{r eval = FALSE}\n~{.x + 10}\n```\n\n`~` indicates that you have started an anonymous function, and the argument of the anonymous function can be referred to using `.x` (or simply `.`). Unlike normal function arguments that can be anything that you like, the tilde-dot function argument is always `.x`.\n\nFor instance, to identify how many missing values there are in every column, we could specify the inline function `~sum(is.na(.))`, which calculates how many `NA` values are in each column (where the column is represented by `.`) and adds them up:\n\n```{r}\npenguins %>%\n  summarise(across(everything(), \n                   ~sum(is.na(.))))\n```\n\n\nThis shows that there are missing values in every column except for the first two (`species` and `island`).\n\n\n# A mutate example\n\nWhat if we want to replace the missing values in the numeric columns with 0 (clearly a terrible choice)? Without the `across()` function, we would apply an `if_else()` function separately to each numeric column, which will replace all `NA` values with 0 and leave all non-`NA` values as they are:\n\n```{r}\nreplace0 <- function(x) {\n  if_else(condition = is.na(x), \n          true = 0, \n          false = as.numeric(x))\n}\npenguins %>%\n  mutate(bill_length_mm = replace0(bill_length_mm),\n         bill_depth_mm = replace0(bill_depth_mm),\n         flipper_length_mm = replace0(flipper_length_mm),\n         body_mass_g = replace0(body_mass_g))\n```\n\n\nBut fortunately, we can do this a lot more efficiently with `across()`.\n\n\n\n```{r}\n# define a function to replace NA with 0\n\npenguins %>%\n  mutate(across(where(is.numeric), replace0))\n```\n\n\nAlthough obviously 0 isn't a great choice, so perhaps we can replace the missing values with the mean value of the column. This time, rather than define a new function (in place of `replace0`), we'll be a bit more concise and use the tilde-dot notation to specify the function we want to apply.\n\n```{r}\npenguins %>%\n  mutate(across(where(is.numeric), ~if_else(is.na(.), mean(., na.rm = T), as.numeric(.))))\n```\n\nOr better yet, perhaps we can replace the missing values with the average value within the relevant species and island.\n\n```{r}\npenguins %>%\n  group_by(species, island) %>%\n  mutate(across(where(is.numeric), \n                ~if_else(condition = is.na(.), \n                         true = mean(., na.rm = T), \n                         false = as.numeric(.)))) %>%\n  ungroup()\n```\n\n# A select example\n\nWhen you're using select, you don't have to include the `across()` function, because the select helpers have always worked with `select()`. This means that you can just write\n\n```{r}\npenguins %>%\n  select(where(is.numeric))\n```\n\nrather than\n\n```{r, eval = FALSE}\npenguins %>%\n  select(across(where(is.numeric)))\n```\n\nwhich will throw an error.\n\n\nHopefully `across()` will make your life easier, as it has mine!\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"2020-07-09-across.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","theme":"simplex","linkcolor":"#6633c4","code-copy":true,"footnotes-hover":true,"title-block-banner":true,"comments":{"utterances":{"repo":"rlbarter/blog_comments"}},"title":"Across (dplyr 1.0.0): applying dplyr functions simultaneously across multiple columns","author":"Rebecca Barter","categories":["R","tidyverse","dplyr"],"date":"2020-07-09","description":"With the introduction of dplyr 1.0.0, there are a few new features: the biggest of which is across() which supersedes the scoped versions of dplyr functions.","toc-location":"left"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}