{
  "hash": "bc594b668f79d8f63110fcf21ce1d966",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Learn to purrr\"\nauthor: \"Rebecca Barter\"\nformat:\n  html:\n    toc: true\n    toc-location: left\ncategories: [R, purrr, tidyverse]\ndate: 2019-08-19\ndescription: \"Purrr is the tidyverse's answer to apply functions for iteration. It's one of those packages that you might have heard of, but seemed too complicated to sit down and learn. Starting with map functions, and taking you on a journey that will harness the power of the list, this post will have you purrring in no time.\" \n---\n\n\n\n> \"It was on the corner of the street that he noticed the first sign of something peculiar - a cat reading a map\"\n- J.K. Rowling\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](img/purrr/cat_map.jpg){fig-align='center'}\n:::\n:::\n\n\n\n\nPurrr is one of those tidyverse packages that you keep hearing about, and you know you should probably learn it, but you just never seem to get around to it. \n\nAt it's core, purrr is all about iteration. Purrr introduces map functions (the tidyverse's answer to base R's apply functions, but more in line with functional programming practices) as well as some new functions for manipulating lists. To get a quick snapshot of any tidyverse package, a nice place to go is the [cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/purrr.pdf). I find these particularly useful after I've already got the basics of a package down, because I inevitably realise that there are a bunch of functionalities I knew nothing about.\n\nAnother useful resource for learning about purrr is [Jenny Bryan's tutorial](https://jennybc.github.io/purrr-tutorial/). Jenny's tutorial is fantastic, but is a lot longer than mine. This post is a lot shorter and my goal is to get you up and running with purrr very quickly.\n\nWhile the workhorse of dplyr is the data frame, the workhorse of purrr is the list. If you aren't familiar with lists, hopefully this will help you understand what they are:\n\n- A **vector** is a way of storing many individual elements (a single number or a single character or string) of the same type together in a single object,\n\n- A **data frame** is a way of storing many vectors of the same length but possibly of different types together in a single object\n\n- A **list** is a way of storing many objects of any type (e.g. data frames, plots, vectors) together in a single object\n\nHere is an example of a list that has three elements: a single number, a vector and a data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_first_list <- list(my_number = 5,\n                      my_vector = c(\"a\", \"b\", \"c\"),\n                      my_dataframe = data.frame(a = 1:3, b = c(\"q\", \"b\", \"z\"), c = c(\"bananas\", \"are\", \"so very great\")))\nmy_first_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```output\n$my_number\n[1] 5\n\n$my_vector\n[1] \"a\" \"b\" \"c\"\n\n$my_dataframe\n  a b             c\n1 1 q       bananas\n2 2 b           are\n3 3 z so very great\n```\n\n\n:::\n:::\n\n\nNote that a data frame is actually a special case of a list where each element of the list is a vector of the same length.\n\n\n# Map functions: beyond apply \n\n\nA **map function** is one that applies the same action/function to every element of an object (e.g. each entry of a list or a vector, or each of the columns of a data frame). \n\nIf you're familiar with the base R `apply()` functions, then it turns out that you are already familiar with map functions, even if you didn't know it!\n\n\nThe `apply()` functions are set of super useful base-R functions for iteratively performing an action across entries of a vector or list without having to write a for-loop. While there is nothing fundamentally wrong with the base R apply functions, the syntax is somewhat inconsistent across the different apply functions, and the expected type of the object they return is often ambiguous (at least it is for `sapply`...). \n\nThe naming convention of the map functions are such that the type of the **output** is specified by the term that follows the underscore in the function name. \n\n- `map(.x, .f)` is the main mapping function and returns a list\n\n- `map_df(.x, .f)` returns a data frame\n\n- `map_dbl(.x, .f)` returns a numeric (double) vector\n\n- `map_chr(.x, .f)` returns a character vector\n\n- `map_lgl(.x, .f)` returns a logical vector\n\nConsistent with the way of the tidyverse, the first argument of each mapping function is always the data object that you want to map over, and the second argument is always the *function* that you want to iteratively apply to each element of the input object. \n\nThe **input** object to any `map` function is always either \n\n- a *vector* (of any type), in which case the iteration is done over the entries of the vector,\n\n- a *list*, in which case the iteration is performed over the elements of the list, \n\n- a *data frame*, in which case the iteration is performed over the columns of the data frame (which, since a data frame is a special kind of list, is technically the same as the previous point).\n\nSince the first argument is always the data, this means that map functions play nicely with pipes (`%>%`). If you've never seen pipes before, they're really useful (originally from the `magrittr` package, but also ported with the `dplyr` package and thus with the `tidyverse`). Piping allows you to string together many functions by piping an object (which itself might be the output of a function) into the first argument of the next function. If you'd like to learn more about pipes, check out my [tidyverse blog posts](http://www.rebeccabarter.com/blog/2019-08-05_base_r_to_tidyverse/).\n\n\nThroughout this post I will demonstrate each of purrr's functionalities using both a simple numeric example (to explain the concept) and the gapminder data (to show a more complex example).\n\n\n\n## Simplest usage: repeated looping with map\n\nFundamentally, maps are for iteration. In the example below I will iterate through the vector `c(1, 4, 7)` by adding 10 to each entry. This function applied to a single number, which we will call `.x`, can be defined as\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddTen <- function(.x) {\n  return(.x + 10)\n}\n```\n:::\n\n\nThe `map()` function below iterates `addTen()` across all entries of the vector, `.x = c(1, 4, 7)`, and returns the output as a list \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nmap(.x = c(1, 4, 7), \n    .f = addTen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 11\n\n[[2]]\n[1] 14\n\n[[3]]\n[1] 17\n```\n\n\n:::\n:::\n\n\nFortunately, you don't actually need to specify the argument names \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(c(1, 4, 7), addTen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 11\n\n[[2]]\n[1] 14\n\n[[3]]\n[1] 17\n```\n\n\n:::\n:::\n\n\nNote that\n\n- the first element of the output is the result of applying the function to the first element of the input (`1`), \n\n- the second element of the output is the result of applying the function to the second element of the input (`4`),\n\n- and the third element of the output is the result of applying the function to the third element of the input (`7`).\n\nThe following code chunks show that no matter if the input object is a vector, a list, or a data frame, `map()` always returns a list.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(list(1, 4, 7), addTen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 11\n\n[[2]]\n[1] 14\n\n[[3]]\n[1] 17\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(data.frame(a = 1, b = 4, c = 7), addTen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 11\n\n$b\n[1] 14\n\n$c\n[1] 17\n```\n\n\n:::\n:::\n\n\nIf we wanted the output of `map` to be some other object type, we need to use a different function. For instance to map the input to a numeric (double) vector, you can use the `map_dbl()` (\"map to a double\") function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(c(1, 4, 7), addTen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 14 17\n```\n\n\n:::\n:::\n\n\nTo map to a character vector, you can use the `map_chr()` (\"map to a character\") function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_chr(c(1, 4, 7), addTen)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Automatic coercion from double to character was deprecated in purrr 1.0.0.\nℹ Please use an explicit call to `as.character()` within `map_chr()` instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"11.000000\" \"14.000000\" \"17.000000\"\n```\n\n\n:::\n:::\n\n\nIf you want to return a data frame, then you would use the `map_df()` function. However, you need to make sure that in each iteration you're returning a data frame which has consistent column names. `map_df` will automatically bind the rows of each iteration. \n\nFor this example, I want to return a data frame whose columns correspond to the original number and the number plus ten.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_df(c(1, 4, 7), function(.x) {\n  return(data.frame(old_number = .x, \n                    new_number = addTen(.x)))\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  old_number new_number\n1          1         11\n2          4         14\n3          7         17\n```\n\n\n:::\n:::\n\n\n\nNote that in this case, I defined an \"anonymous\" function as our output for each iteration. An anonymous function is a temporary function (that you define as the function argument to the map). Here I used the argument name `.x`, but I could have used anything. \n\nAnother function to be aware of is `modify()`, which is just like the map functions, but always returns an object the same type as the input object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nmodify(c(1, 4, 7), addTen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 14 17\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodify(list(1, 4, 7), addTen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 11\n\n[[2]]\n[1] 14\n\n[[3]]\n[1] 17\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodify(data.frame(1, 4, 7), addTen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  X1 X4 X7\n1 11 14 17\n```\n\n\n:::\n:::\n\n\n\nModify also has a pretty useful sibling, `modify_if()`, that only applies the function to elements that satisfy a specific criteria (specified by a \"predicate function\", the second argument called `.p`). For instance, the following example only modifies the third entry since it is greater than 5.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodify_if(.x = list(1, 4, 7), \n          .p = function(x) x > 5,\n          .f = addTen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 17\n```\n\n\n:::\n:::\n\n\n## The tilde-dot shorthand for functions\n\n\nTo make the code more concise you can use the tilde-dot shorthand for anonymous functions (the functions that you create as arguments of other functions).\n\nThe notation works by replacing\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction(x) {\n  x + 10\n}\n```\n:::\n\n\nwith \n\n\n::: {.cell}\n\n```{.r .cell-code}\n~{.x + 10}\n```\n:::\n\n\n`~` indicates that you have started an anonymous function, and the argument of the anonymous function can be referred to using `.x` (or simply `.`). Unlike normal function arguments that can be anything that you like, the tilde-dot function argument is always `.x`.\n\n\nThus, instead of defining the `addTen()` function separately, we could use the tilde-dot shorthand\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(c(1, 4, 7), ~{.x + 10})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 14 17\n```\n\n\n:::\n:::\n\n\n\n## Applying map functions in a slightly more interesting context\n\nThroughout this tutorial, we will use the gapminder dataset that can be loaded directly if you're connected to the internet. Each function will first be demonstrated using a simple numeric example, and then will be demonstrated using a more complex practical example based on the gapminder dataset.\n\nMy general workflow involves loading the original data and saving it as an object with a meaningful name and an `_orig` suffix. I then define a copy of the original dataset without the `_orig` suffix. Having an original copy of my data in my environment means that it is easy to check that my manipulations do what I expected. I will make direct data cleaning modifications to the `gapminder` data frame, but will never edit the `gapminder_orig` data frame. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# to download the data directly:\ngapminder_orig <- read.csv(\"https://raw.githubusercontent.com/rlbarter/personal-website-quarto/main/blog/data/gapminder.csv\")\n# define a copy of the original dataset that we will clean and play with \ngapminder <- gapminder_orig\n```\n:::\n\n\nThe gapminder dataset has 1704 rows containing information on population, life expectancy and GDP per capita by year and country. \n\nA \"tidy\" data frame is one where every row is a single observational unit (in this case, indexed by country and year), and every column corresponds to a variable that is measured for each observational unit (in this case, for each country and year, a measurement is made for population, continent, life expectancy and GDP). If you'd like to learn more about \"tidy data\", I highly recommend reading [Hadley Wickham's tidy data article](vita.had.co.nz/papers/tidy-data.pdf). \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1704    6\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      country continent year lifeExp      pop gdpPercap\n1 Afghanistan      Asia 1952  28.801  8425333  779.4453\n2 Afghanistan      Asia 1957  30.332  9240934  820.8530\n3 Afghanistan      Asia 1962  31.997 10267083  853.1007\n4 Afghanistan      Asia 1967  34.020 11537966  836.1971\n5 Afghanistan      Asia 1972  36.088 13079460  739.9811\n6 Afghanistan      Asia 1977  38.438 14880372  786.1134\n```\n\n\n:::\n:::\n\n\nSince `gapminder` is a data frame, the `map_` functions will iterate over each column. An example of simple usage of the `map_` functions is to summarize each column. For instance, you can identify the type of each column by applying the `class()` function to each column. Since the output of the `class()` function is a character, we will use the `map_chr()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# apply the class() function to each column\ngapminder %>% map_chr(class)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    country   continent        year     lifeExp         pop   gdpPercap \n\"character\" \"character\"   \"integer\"   \"numeric\"   \"integer\"   \"numeric\" \n```\n\n\n:::\n:::\n\n\nI frequently do this to get a quick snapshot of each column type of a new dataset directly in the console.  As a habit, I usually pipe in the data using `%>%`, rather than provide it as an argument. Remember that the pipe places the object to the left of the pipe in the first argument of the function to the right.\n\nSimilarly, if you wanted to identify the number of distinct values in each column, you could apply the `n_distinct()` function from the dplyr package to each column. Since the output of `n_distinct()` is a numeric (a double), you might want to use the `map_dbl()` function so that the results of each iteration (the application of `n_distinct()` to each column) are concatenated into a numeric vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# apply the n_distinct() function to each column\ngapminder %>% map_dbl(n_distinct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  country continent      year   lifeExp       pop gdpPercap \n      142         5        12      1626      1704      1704 \n```\n\n\n:::\n:::\n\n\nIf you want to do something a little more complicated, such return a few different summaries of each column in a data frame, you can use `map_df()`. When things are getting a little bit more complicated, you typically need to define an anonymous function that you want to apply to each column. Using the tilde-dot notation, the anonymous function below calculates the number of distinct entries and the type of the current column (which is accessible as `.x`), and then combines them into a two-column data frame. Once it has iterated through each of the columns, the `map_df` function combines the data frames row-wise into a single data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% map_df(~(data.frame(n_distinct = n_distinct(.x),\n                                  class = class(.x))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  n_distinct     class\n1        142 character\n2          5 character\n3         12   integer\n4       1626   numeric\n5       1704   integer\n6       1704   numeric\n```\n\n\n:::\n:::\n\n\nNote that we've lost the variable names! The variable names correspond to the names of the objects over which we are iterating (in this case, the column names), and these are not automatically included as a column in the output data frame. You can tell `map_df()` to include them using the `.id` argument of `map_df()`. This will automatically take the name of the element being iterated over and include it in the column corresponding to whatever you set `.id` to.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% map_df(~(data.frame(n_distinct = n_distinct(.x),\n                                  class = class(.x))),\n                     .id = \"variable\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   variable n_distinct     class\n1   country        142 character\n2 continent          5 character\n3      year         12   integer\n4   lifeExp       1626   numeric\n5       pop       1704   integer\n6 gdpPercap       1704   numeric\n```\n\n\n:::\n:::\n\n\n\nIf you're having trouble thinking through these map actions, I recommend that you first figure out what the code would be to do what you want for a single element, and then paste it into the `map_df()` function (a nice trick I saw Hadley Wickham used a few years ago when he presented on purrr at RLadies SF).\n\nFor instance, since the first element of the gapminder data frame is the first column, let's define `.x` in our environment to be this first column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# take the first element of the gapminder data\n.x <- gapminder %>% pluck(1)\n# look at the first 6 rows\nhead(.x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\"\n[6] \"Afghanistan\"\n```\n\n\n:::\n:::\n\n\n\nThen, you can create a data frame for this column that contains the number of distinct entries, and the class of the column. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(n_distinct = n_distinct(.x),\n           class = class(.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  n_distinct     class\n1        142 character\n```\n\n\n:::\n:::\n\n\nSince this has done what was expected want for the first column, you can paste this code into the map function using the tilde-dot shorthand.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% map_df(~(data.frame(n_distinct = n_distinct(.x),\n                                  class = class(.x))),\n                     .id = \"variable\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   variable n_distinct     class\n1   country        142 character\n2 continent          5 character\n3      year         12   integer\n4   lifeExp       1626   numeric\n5       pop       1704   integer\n6 gdpPercap       1704   numeric\n```\n\n\n:::\n:::\n\n\n\n`map_df()` is definitely one of the most powerful functions of `purrr` in my opinion, and is probably the one that I use most. \n\n\n## Maps with multiple input objects\n\nAfter gaining a basic understanding of purrr's map functions, you can start to do some fancier stuff. For instance, what if you want to perform a map that iterates through two objects. The code below uses map functions to create a *list of plots* that compare life expectancy and GDP per capita for each continent/year combination.\n\nThe map function that maps over two objects instead of 1 is called `map2()`. The first two arguments are the two objects you want to iterate over, and the third is the function (with two arguments, one for each object).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap2(.x = object1, # the first object to iterate over\n     .y = object2, # the second object to iterate over\n     .f = plotFunction(.x, .y))\n```\n:::\n\n\nFirst, you need to define a vector (or list) of continents and a paired vector (or list) of years that you want to iterate through. Note that in our continent/year example\n\n- the *first iteration* will correspond to the *first continent* in the continent vector and the *first year* in the year vector,\n\n- the *second iteration* will correspond to the *second continent* in the continent vector and the *second year* in the year vector.\n\nThis might seem obvious, but it is a natural instinct to incorrectly assume that `map2()` will automatically perform the action on *all* combinations that can be made from the two vectors. For instance if you have a continent vector `.x = c(\"Americas\", \"Asia\")` and a year vector `.y = c(1952, 2007)`, then you might assume that `map2` will iterate over the Americas for 1952 and for 2007, and then Asia for 1952 and 2007. It won't though. The iteration will actually be first the Americas for 1952 only, and then Asia for 2007 only. \n\nFirst, let's get our vectors of continents and years, starting by obtaining all distinct combinations of continents and years that appear in the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinent_year <- gapminder %>% distinct(continent, year)\ncontinent_year\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   continent year\n1       Asia 1952\n2       Asia 1957\n3       Asia 1962\n4       Asia 1967\n5       Asia 1972\n6       Asia 1977\n7       Asia 1982\n8       Asia 1987\n9       Asia 1992\n10      Asia 1997\n11      Asia 2002\n12      Asia 2007\n13    Europe 1952\n14    Europe 1957\n15    Europe 1962\n16    Europe 1967\n17    Europe 1972\n18    Europe 1977\n19    Europe 1982\n20    Europe 1987\n21    Europe 1992\n22    Europe 1997\n23    Europe 2002\n24    Europe 2007\n25    Africa 1952\n26    Africa 1957\n27    Africa 1962\n28    Africa 1967\n29    Africa 1972\n30    Africa 1977\n31    Africa 1982\n32    Africa 1987\n33    Africa 1992\n34    Africa 1997\n35    Africa 2002\n36    Africa 2007\n37  Americas 1952\n38  Americas 1957\n39  Americas 1962\n40  Americas 1967\n41  Americas 1972\n42  Americas 1977\n43  Americas 1982\n44  Americas 1987\n45  Americas 1992\n46  Americas 1997\n47  Americas 2002\n48  Americas 2007\n49   Oceania 1952\n50   Oceania 1957\n51   Oceania 1962\n52   Oceania 1967\n53   Oceania 1972\n54   Oceania 1977\n55   Oceania 1982\n56   Oceania 1987\n57   Oceania 1992\n58   Oceania 1997\n59   Oceania 2002\n60   Oceania 2007\n```\n\n\n:::\n:::\n\n\nThen extracting the continent and year pairs as separate vectors\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract the continent and year pairs as separate vectors\ncontinents <- continent_year %>% pull(continent) %>% as.character\nyears <- continent_year %>% pull(year)\n```\n:::\n\n\nIf you want to use tilde-dot short-hand, the anonymous arguments will be `.x` for the first object being iterated over, and `.y` for the second object being iterated over. \n\nBefore jumping straight into the map function, it's a good idea to first figure out what the code will be for just first iteration (the first continent and the first year, which happen to be Asia in 1952). \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# try to figure out the code for the first example\n.x <- continents[1]\n.y <- years[1]\n# make a scatterplot of GDP vs life expectancy in all Asian countries for 1952\ngapminder %>% \n  filter(continent == .x,\n         year == .y) %>%\n  ggplot() +\n  geom_point(aes(x = gdpPercap, y = lifeExp)) +\n  ggtitle(glue::glue(.x, \" \", .y))\n```\n\n::: {.cell-output-display}\n![](2019-08-19_purrr_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\nThis seems to have worked. So you can then copy-and-paste the code into the `map2` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_list <- map2(.x = continents, \n                  .y = years, \n                  .f = ~{\n                    gapminder %>% \n                      filter(continent == .x,\n                             year == .y) %>%\n                      ggplot() +\n                      geom_point(aes(x = gdpPercap, y = lifeExp)) +\n                      ggtitle(glue::glue(.x, \" \", .y))\n                  })\n```\n:::\n\n\nAnd you can look at a few of the entries of the list to see that they make sense\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_list[[1]]\n```\n\n::: {.cell-output-display}\n![](2019-08-19_purrr_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot_list[[22]]\n```\n\n::: {.cell-output-display}\n![](2019-08-19_purrr_files/figure-html/unnamed-chunk-32-2.png){width=672}\n:::\n:::\n\n\n`pmap()` allows you to iterate over an arbitrary number of objects (i.e. more than two).\n\n\n\n## List columns and Nested data frames\n\nTibbles are tidyverse data frames. Some crazy stuff starts happening when you learn that tibble columns can be lists (as opposed to vectors, which is what they usually are). This is where the difference between tibbles and data frames becomes real. \n\nFor instance, a tibble can be \"nested\" where the tibble is essentially split into separate data frames based on a grouping variable, and these separate data frames are stored as entries of a list (that is then stored in the `data` column of the data frame).\n\nBelow I nest the gapminder data by continent.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_nested <- gapminder %>% \n  group_by(continent) %>% \n  nest()\ngapminder_nested\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n# Groups:   continent [5]\n  continent data              \n  <chr>     <list>            \n1 Asia      <tibble [396 × 5]>\n2 Europe    <tibble [360 × 5]>\n3 Africa    <tibble [624 × 5]>\n4 Americas  <tibble [300 × 5]>\n5 Oceania   <tibble [24 × 5]> \n```\n\n\n:::\n:::\n\n\nThe first column is the variable that we grouped by, `continent`, and the second column is the rest of the data frame corresponding to that group (as if you had filtered the data frame to the specific continent). To see this, the code below shows that the first entry in the `data` column corresponds to the entire gapminder dataset for Asia.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_nested$data[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 396 × 5\n   country      year lifeExp      pop gdpPercap\n   <chr>       <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan  1952    28.8  8425333      779.\n 2 Afghanistan  1957    30.3  9240934      821.\n 3 Afghanistan  1962    32.0 10267083      853.\n 4 Afghanistan  1967    34.0 11537966      836.\n 5 Afghanistan  1972    36.1 13079460      740.\n 6 Afghanistan  1977    38.4 14880372      786.\n 7 Afghanistan  1982    39.9 12881816      978.\n 8 Afghanistan  1987    40.8 13867957      852.\n 9 Afghanistan  1992    41.7 16317921      649.\n10 Afghanistan  1997    41.8 22227415      635.\n# ℹ 386 more rows\n```\n\n\n:::\n:::\n\n\nUsing dplyr `pluck()` function, this can be written as \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_nested %>% \n  # extract the first entry from the data column\n  pluck(\"data\", 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 396 × 5\n   country      year lifeExp      pop gdpPercap\n   <chr>       <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan  1952    28.8  8425333      779.\n 2 Afghanistan  1957    30.3  9240934      821.\n 3 Afghanistan  1962    32.0 10267083      853.\n 4 Afghanistan  1967    34.0 11537966      836.\n 5 Afghanistan  1972    36.1 13079460      740.\n 6 Afghanistan  1977    38.4 14880372      786.\n 7 Afghanistan  1982    39.9 12881816      978.\n 8 Afghanistan  1987    40.8 13867957      852.\n 9 Afghanistan  1992    41.7 16317921      649.\n10 Afghanistan  1997    41.8 22227415      635.\n# ℹ 386 more rows\n```\n\n\n:::\n:::\n\n\nSimilarly, the 5th entry in the `data` column corresponds to the entire gapminder dataset for Oceania.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_nested %>% pluck(\"data\", 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 × 5\n   country    year lifeExp      pop gdpPercap\n   <chr>     <int>   <dbl>    <int>     <dbl>\n 1 Australia  1952    69.1  8691212    10040.\n 2 Australia  1957    70.3  9712569    10950.\n 3 Australia  1962    70.9 10794968    12217.\n 4 Australia  1967    71.1 11872264    14526.\n 5 Australia  1972    71.9 13177000    16789.\n 6 Australia  1977    73.5 14074100    18334.\n 7 Australia  1982    74.7 15184200    19477.\n 8 Australia  1987    76.3 16257249    21889.\n 9 Australia  1992    77.6 17481977    23425.\n10 Australia  1997    78.8 18565243    26998.\n# ℹ 14 more rows\n```\n\n\n:::\n:::\n\n\nYou might be asking at this point *why* you would ever want to nest your data frame? It just doesn't seem like that useful a thing to do... until you realise that you now have the power to use dplyr manipulations on more complex objects that can be stored in a list. \n\nHowever, since actions such as `mutate()` are applied directly to the entire column (which is usually a vector, so is fine), we run into issues when we try to mutate a list. For instance, since columns are usually vectors, normal vectorized functions work just fine on them\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(vec_col = 1:10) %>%\n  mutate(vec_sum = sum(vec_col))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n   vec_col vec_sum\n     <int>   <int>\n 1       1      55\n 2       2      55\n 3       3      55\n 4       4      55\n 5       5      55\n 6       6      55\n 7       7      55\n 8       8      55\n 9       9      55\n10      10      55\n```\n\n\n:::\n:::\n\n\nbut when the column is a list, vectorized functions don't know what to do with them, and we get an error that says `Error in sum(x) : invalid 'type' (list) of argument`. Try \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(list_col = list(c(1, 5, 7), \n                       5, \n                       c(10, 10, 11))) %>%\n  mutate(list_sum = sum(list_col))\n```\n:::\n\n\nTo apply mutate functions to a list-column, you need to wrap the function you want to apply in a map function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(list_col = list(c(1, 5, 7), \n                       5, \n                       c(10, 10, 11))) %>%\n  mutate(list_sum = map(list_col, sum))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  list_col  list_sum \n  <list>    <list>   \n1 <dbl [3]> <dbl [1]>\n2 <dbl [1]> <dbl [1]>\n3 <dbl [3]> <dbl [1]>\n```\n\n\n:::\n:::\n\n\nSince `map()` returns a list itself, the `list_sum` column is thus itself a list\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(list_col = list(c(1, 5, 7), \n                       5, \n                       c(10, 10, 11))) %>%\n  mutate(list_sum = map(list_col, sum)) %>% \n  pull(list_sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 13\n\n[[2]]\n[1] 5\n\n[[3]]\n[1] 31\n```\n\n\n:::\n:::\n\n\n\nWhat could we do if we wanted it to be a vector? We could use the `map_dbl()` function instead!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(list_col = list(c(1, 5, 7), \n                       5, \n                       c(10, 10, 11))) %>%\n  mutate(list_sum = map_dbl(list_col, sum))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  list_col  list_sum\n  <list>       <dbl>\n1 <dbl [3]>       13\n2 <dbl [1]>        5\n3 <dbl [3]>       31\n```\n\n\n:::\n:::\n\n\n### Nesting the gapminder data\n\nLet's return to the nested gapminder dataset. I want to calculate the average life expectancy within each continent and add it as a new column using `mutate()`. Based on the example above, can you explain why the following code doesn't work?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_nested %>% \n  mutate(avg_lifeExp = mean(data$lifeExp))\n```\n:::\n\n\n\nI was hoping that this code would extract the `lifeExp` column from each data frame. But I'm applying the mutate to the `data` column, which itself doesn't have an entry called `lifeExp` since it's a *list* of data frames. How could I get access to the `lifeExp` column of the data frames stored in the `data` list? Using a `map` function of course!\n\nThink of an individual data frame as `.x`. Again, I will first figure out the code for calculating the mean life expectancy for the first entry of the column. The following code defines `.x` to be the first entry of the `data` column (this is the data frame for Asia).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the first entry of the \"data\" column\n.x <- gapminder_nested %>% pluck(\"data\", 1)\n.x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 396 × 5\n   country      year lifeExp      pop gdpPercap\n   <chr>       <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan  1952    28.8  8425333      779.\n 2 Afghanistan  1957    30.3  9240934      821.\n 3 Afghanistan  1962    32.0 10267083      853.\n 4 Afghanistan  1967    34.0 11537966      836.\n 5 Afghanistan  1972    36.1 13079460      740.\n 6 Afghanistan  1977    38.4 14880372      786.\n 7 Afghanistan  1982    39.9 12881816      978.\n 8 Afghanistan  1987    40.8 13867957      852.\n 9 Afghanistan  1992    41.7 16317921      649.\n10 Afghanistan  1997    41.8 22227415      635.\n# ℹ 386 more rows\n```\n\n\n:::\n:::\n\n\nThen to calculate the average life expectancy for Asia, I could write \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(.x$lifeExp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 60.0649\n```\n\n\n:::\n:::\n\n\nSo copy-pasting this into the tilde-dot anonymous function argument of the `map_dbl()` function within `mutate()`, I get what I wanted! \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_nested %>% \n  mutate(avg_lifeExp = map_dbl(data, ~{mean(.x$lifeExp)}))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n# Groups:   continent [5]\n  continent data               avg_lifeExp\n  <chr>     <list>                   <dbl>\n1 Asia      <tibble [396 × 5]>        60.1\n2 Europe    <tibble [360 × 5]>        71.9\n3 Africa    <tibble [624 × 5]>        48.9\n4 Americas  <tibble [300 × 5]>        64.7\n5 Oceania   <tibble [24 × 5]>         74.3\n```\n\n\n:::\n:::\n\n\nThis code iterates through the data frames stored in the `data` column, returns the average life expectancy for each data frame, and concatonates the results into a numeric vector (which is then stored as a column called `avg_lifeExp`).\n\nI hear what you're saying... this is something that we could have done a lot more easily using standard dplyr commands (such as `summarise()`). True, but hopefully it helped you understand why you need to wrap mutate functions inside map functions when applying them to list columns. \n\n\nEven if this example was less than inspiring, I promise the next example will knock your socks off!\n\nThe next exampe will demonstrate how to fit a model separately for each continent, and evaluate it, all within a single tibble. First, I will fit a linear model for each continent and store it as a list-column. If the data frame for a single continent is `.x`, then the model I want to fit is `lm(lifeExp ~ pop + gdpPercap + year, data = .x)` (check for yourself that this does what you expect). So I can copy-past this command into the `map()` function within the `mutate()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# fit a model separately for each continent\ngapminder_nested <- gapminder_nested %>% \n  mutate(lm_obj = map(data, ~lm(lifeExp ~ pop + gdpPercap + year, data = .x)))\ngapminder_nested\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n# Groups:   continent [5]\n  continent data               lm_obj\n  <chr>     <list>             <list>\n1 Asia      <tibble [396 × 5]> <lm>  \n2 Europe    <tibble [360 × 5]> <lm>  \n3 Africa    <tibble [624 × 5]> <lm>  \n4 Americas  <tibble [300 × 5]> <lm>  \n5 Oceania   <tibble [24 × 5]>  <lm>  \n```\n\n\n:::\n:::\n\n\nWhere the first linear model (for Asia) is\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_nested %>% pluck(\"lm_obj\", 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = lifeExp ~ pop + gdpPercap + year, data = .x)\n\nCoefficients:\n(Intercept)          pop    gdpPercap         year  \n -7.833e+02    4.228e-11    2.510e-04    4.251e-01  \n```\n\n\n:::\n:::\n\n\nI can then predict the response for the data stored in the `data` column using the corresponding linear model. So I have two objects I want to iterate over: the data and the linear model object. This means I want to use `map2()`. When things get a little more complicated I like to have multiple function arguments, so I'm going to use a full anonymous function rather than the tilde-dot shorthand. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# predict the response for each continent\ngapminder_nested <- gapminder_nested %>% \n  mutate(pred = map2(lm_obj, data, function(.lm, .data) predict(.lm, .data)))\ngapminder_nested\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n# Groups:   continent [5]\n  continent data               lm_obj pred       \n  <chr>     <list>             <list> <list>     \n1 Asia      <tibble [396 × 5]> <lm>   <dbl [396]>\n2 Europe    <tibble [360 × 5]> <lm>   <dbl [360]>\n3 Africa    <tibble [624 × 5]> <lm>   <dbl [624]>\n4 Americas  <tibble [300 × 5]> <lm>   <dbl [300]>\n5 Oceania   <tibble [24 × 5]>  <lm>   <dbl [24]> \n```\n\n\n:::\n:::\n\n\nAnd I can then calculate the correlation between the predicted response and the true response, this time using the `map2()_dbl` function since I want the output the be a numeric vector rather than a list of single elements.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate the correlation between observed and predicted response for each continent\ngapminder_nested <- gapminder_nested %>% \n  mutate(cor = map2_dbl(pred, data, function(.pred, .data) cor(.pred, .data$lifeExp)))\ngapminder_nested\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n# Groups:   continent [5]\n  continent data               lm_obj pred          cor\n  <chr>     <list>             <list> <list>      <dbl>\n1 Asia      <tibble [396 × 5]> <lm>   <dbl [396]> 0.723\n2 Europe    <tibble [360 × 5]> <lm>   <dbl [360]> 0.834\n3 Africa    <tibble [624 × 5]> <lm>   <dbl [624]> 0.645\n4 Americas  <tibble [300 × 5]> <lm>   <dbl [300]> 0.779\n5 Oceania   <tibble [24 × 5]>  <lm>   <dbl [24]>  0.987\n```\n\n\n:::\n:::\n\n\nHoly guacamole, that is so awesome!\n\n\n\n## Advanced exercise\n\nThe goal of this exercise is to fit a separate linear model for each continent without splitting up the data. Create the following data frame that has the continent, each term in the model for the continent, its linear model coefficient estimate, and standard error.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 6\n   continent term         estimate std.error statistic  p.value\n   <chr>     <chr>           <dbl>     <dbl>     <dbl>    <dbl>\n 1 Asia      (Intercept) -7.83e+ 2   4.83e+1  -16.2    1.22e-45\n 2 Asia      pop          4.23e-11   2.04e-9    0.0207 9.83e- 1\n 3 Asia      year         4.25e- 1   2.44e-2   17.4    1.13e-50\n 4 Asia      gdpPercap    2.51e- 4   3.01e-5    8.34   1.31e-15\n 5 Europe    (Intercept) -1.61e+ 2   2.28e+1   -7.09   7.44e-12\n 6 Europe    pop         -8.18e- 9   7.80e-9   -1.05   2.95e- 1\n 7 Europe    year         1.16e- 1   1.16e-2    9.96   8.88e-21\n 8 Europe    gdpPercap    3.25e- 4   2.15e-5   15.2    2.21e-40\n 9 Africa    (Intercept) -4.70e+ 2   3.39e+1  -13.9    2.17e-38\n10 Africa    pop         -3.68e- 9   1.89e-8   -0.195  8.45e- 1\n11 Africa    year         2.61e- 1   1.71e-2   15.2    1.07e-44\n12 Africa    gdpPercap    1.12e- 3   1.01e-4   11.1    2.46e-26\n13 Americas  (Intercept) -5.33e+ 2   4.10e+1  -13.0    6.40e-31\n14 Americas  pop         -2.15e- 8   8.62e-9   -2.49   1.32e- 2\n15 Americas  year         3.00e- 1   2.08e-2   14.4    3.79e-36\n16 Americas  gdpPercap    6.75e- 4   7.15e-5    9.44   1.13e-18\n17 Oceania   (Intercept) -2.10e+ 2   5.12e+1   -4.10   5.61e- 4\n18 Oceania   pop          8.37e- 9   3.34e-8    0.251  8.05e- 1\n19 Oceania   year         1.42e- 1   2.65e-2    5.34   3.19e- 5\n20 Oceania   gdpPercap    2.03e- 4   8.47e-5    2.39   2.66e- 2\n```\n\n\n:::\n:::\n\n\nHint: starting from the `gapminder` dataset, use `group_by()` and `nest()` to nest by continent, use a mutate together with `map` to fit a linear model for each continent, use another mutate with `broom::tidy()` to get a data frame of model coefficients for each model, and a `transmute` to get just the columns you want, followed by an `unnest()` to re-expand the nested tibble. \n\nThe solution code is at the end of this post.\n\nIf you want to stop here, you will already know more than most purrr users. The remainder of this blog post involves little-used features of purrr for manipulating lists.\n\n\n\n# Additional purrr functionalities for lists\n\n\nTo demonstrate how to use purrr to manipulate lists, we will split the gapminder dataset into a *list of data frames* (which is kind of like the converse of a data frame containing a list-column). To make sure it's easy to follow, we will only keep 5 rows from each continent.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(23489)\ngapminder_list <- gapminder %>% split(gapminder$continent) %>%\n  map(~sample_n(., 5))\ngapminder_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Africa\n            country continent year lifeExp      pop gdpPercap\n1            Gambia    Africa 1967  35.857   439593  734.7829\n2      Sierra Leone    Africa 1967  34.113  2662190 1206.0435\n3           Namibia    Africa 1997  58.909  1774766 3899.5243\n4 Equatorial Guinea    Africa 1992  47.545   387838 1132.0550\n5     Cote d'Ivoire    Africa 2002  46.832 16252726 1648.8008\n\n$Americas\n             country continent year lifeExp     pop gdpPercap\n1 Dominican Republic  Americas 1997  69.957 7992357  3614.101\n2        Puerto Rico  Americas 1987  74.630 3444468 12281.342\n3           Honduras  Americas 1992  66.399 5077347  3081.695\n4            Uruguay  Americas 2007  76.384 3447496 10611.463\n5         Costa Rica  Americas 1962  62.842 1345187  3460.937\n\n$Asia\n      country continent year lifeExp       pop gdpPercap\n1     Lebanon      Asia 1967  63.870   2186894 6006.9830\n2       Nepal      Asia 1962  39.393  10332057  652.3969\n3 Yemen, Rep.      Asia 1992  55.599  13367997 1879.4967\n4       India      Asia 1972  50.651 567000000  724.0325\n5    Cambodia      Asia 1952  39.417   4693836  368.4693\n\n$Europe\n         country continent year lifeExp      pop gdpPercap\n1 United Kingdom    Europe 2002  78.471 59912431  29479.00\n2         Greece    Europe 1997  77.869 10502372  18747.70\n3        Belgium    Europe 2002  78.320 10311970  30485.88\n4        Croatia    Europe 2002  74.876  4481020  11628.39\n5    Netherlands    Europe 1967  73.820 12596822  15363.25\n\n$Oceania\n      country continent year lifeExp      pop gdpPercap\n1   Australia   Oceania 1982  74.740 15184200  19477.01\n2 New Zealand   Oceania 1997  77.550  3676187  21050.41\n3 New Zealand   Oceania 2007  80.204  4115771  25185.01\n4   Australia   Oceania 2007  81.235 20434176  34435.37\n5 New Zealand   Oceania 1952  69.390  1994794  10556.58\n```\n\n\n:::\n:::\n\n\n## Keep/Discard: select_if for lists\n\n`keep()` only keeps elements of a list that satisfy a given condition, much like `select_if()` selects columns of a data frame that satisfy a given condition.\n\nThe following code only keeps the gapminder continent data frames (the elements of the list) that have an average (among the sample of 5 rows) life expectancy of at least 70.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_list %>%\n  keep(~{mean(.x$lifeExp) > 70})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Americas\n             country continent year lifeExp     pop gdpPercap\n1 Dominican Republic  Americas 1997  69.957 7992357  3614.101\n2        Puerto Rico  Americas 1987  74.630 3444468 12281.342\n3           Honduras  Americas 1992  66.399 5077347  3081.695\n4            Uruguay  Americas 2007  76.384 3447496 10611.463\n5         Costa Rica  Americas 1962  62.842 1345187  3460.937\n\n$Europe\n         country continent year lifeExp      pop gdpPercap\n1 United Kingdom    Europe 2002  78.471 59912431  29479.00\n2         Greece    Europe 1997  77.869 10502372  18747.70\n3        Belgium    Europe 2002  78.320 10311970  30485.88\n4        Croatia    Europe 2002  74.876  4481020  11628.39\n5    Netherlands    Europe 1967  73.820 12596822  15363.25\n\n$Oceania\n      country continent year lifeExp      pop gdpPercap\n1   Australia   Oceania 1982  74.740 15184200  19477.01\n2 New Zealand   Oceania 1997  77.550  3676187  21050.41\n3 New Zealand   Oceania 2007  80.204  4115771  25185.01\n4   Australia   Oceania 2007  81.235 20434176  34435.37\n5 New Zealand   Oceania 1952  69.390  1994794  10556.58\n```\n\n\n:::\n:::\n\n\n`discard()` does the opposite of `keep()`: it discards any elements that satisfy your logical condition.\n\n\n## Reduce\n\n\n`reduce()` is designed to combine (reduces) all of the elements of a list into a single object by iteratively applying a binary function (a function that takes two inputs). \n\nFor instance, applying a reduce function to add up all of the elements of the vector `c(1, 2, 3)` is like doing `sum(sum(1, 2), 3)`: first it applies `sum` to `1` and `2`, then it applies `sum` again to the output of `sum(1, 2)` and `3`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreduce(c(1, 2, 3), sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n`accumulate()` also returns the intermediate values. \n\n\n::: {.cell}\n\n```{.r .cell-code}\naccumulate(c(1, 2, 3), sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 6\n```\n\n\n:::\n:::\n\n\nAn example of when `reduce()` might come in handy is when you want to perform many `left_join()`s in a row, or to do repeated `rbinds()` (e.g. to bind the rows of the list back together into a single data frame)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_list %>%\n  reduce(rbind)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              country continent year lifeExp       pop  gdpPercap\n1              Gambia    Africa 1967  35.857    439593   734.7829\n2        Sierra Leone    Africa 1967  34.113   2662190  1206.0435\n3             Namibia    Africa 1997  58.909   1774766  3899.5243\n4   Equatorial Guinea    Africa 1992  47.545    387838  1132.0550\n5       Cote d'Ivoire    Africa 2002  46.832  16252726  1648.8008\n6  Dominican Republic  Americas 1997  69.957   7992357  3614.1013\n7         Puerto Rico  Americas 1987  74.630   3444468 12281.3419\n8            Honduras  Americas 1992  66.399   5077347  3081.6946\n9             Uruguay  Americas 2007  76.384   3447496 10611.4630\n10         Costa Rica  Americas 1962  62.842   1345187  3460.9370\n11            Lebanon      Asia 1967  63.870   2186894  6006.9830\n12              Nepal      Asia 1962  39.393  10332057   652.3969\n13        Yemen, Rep.      Asia 1992  55.599  13367997  1879.4967\n14              India      Asia 1972  50.651 567000000   724.0325\n15           Cambodia      Asia 1952  39.417   4693836   368.4693\n16     United Kingdom    Europe 2002  78.471  59912431 29478.9992\n17             Greece    Europe 1997  77.869  10502372 18747.6981\n18            Belgium    Europe 2002  78.320  10311970 30485.8838\n19            Croatia    Europe 2002  74.876   4481020 11628.3890\n20        Netherlands    Europe 1967  73.820  12596822 15363.2514\n21          Australia   Oceania 1982  74.740  15184200 19477.0093\n22        New Zealand   Oceania 1997  77.550   3676187 21050.4138\n23        New Zealand   Oceania 2007  80.204   4115771 25185.0091\n24          Australia   Oceania 2007  81.235  20434176 34435.3674\n25        New Zealand   Oceania 1952  69.390   1994794 10556.5757\n```\n\n\n:::\n:::\n\n\n\n\n## Logical statements for lists\n\nAsking logical questions of a list can be done using `every()` and `some()`. For instance to ask whether *every* continent has average life expectancy greater than 70, you can use `every()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_list %>% every(~{mean(.x$life) > 70})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nTo ask whether *some* continents have average life expectancy greater than 70, you can use `some()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_list %>% some(~{mean(.x$life) > 70})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nAn equivalent of `%in%` for lists is `has_element()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(1, c(2, 5, 1), \"a\") %>% has_element(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nMost of these functions also work on vectors.\n\nNow go forth and purrr!\n\n\n\n# Answer to advanced exercise\n\n\nThe following code produces the table from the exercise above\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  group_by(continent) %>% \n  nest() %>%\n  mutate(lm_obj = map(data, ~lm(lifeExp ~ pop + year + gdpPercap, data = .))) %>%\n  mutate(lm_tidy = map(lm_obj, broom::tidy)) %>%\n  ungroup() %>%\n  transmute(continent, lm_tidy) %>%\n  unnest(cols = c(lm_tidy))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 6\n   continent term         estimate std.error statistic  p.value\n   <chr>     <chr>           <dbl>     <dbl>     <dbl>    <dbl>\n 1 Asia      (Intercept) -7.83e+ 2   4.83e+1  -16.2    1.22e-45\n 2 Asia      pop          4.23e-11   2.04e-9    0.0207 9.83e- 1\n 3 Asia      year         4.25e- 1   2.44e-2   17.4    1.13e-50\n 4 Asia      gdpPercap    2.51e- 4   3.01e-5    8.34   1.31e-15\n 5 Europe    (Intercept) -1.61e+ 2   2.28e+1   -7.09   7.44e-12\n 6 Europe    pop         -8.18e- 9   7.80e-9   -1.05   2.95e- 1\n 7 Europe    year         1.16e- 1   1.16e-2    9.96   8.88e-21\n 8 Europe    gdpPercap    3.25e- 4   2.15e-5   15.2    2.21e-40\n 9 Africa    (Intercept) -4.70e+ 2   3.39e+1  -13.9    2.17e-38\n10 Africa    pop         -3.68e- 9   1.89e-8   -0.195  8.45e- 1\n11 Africa    year         2.61e- 1   1.71e-2   15.2    1.07e-44\n12 Africa    gdpPercap    1.12e- 3   1.01e-4   11.1    2.46e-26\n13 Americas  (Intercept) -5.33e+ 2   4.10e+1  -13.0    6.40e-31\n14 Americas  pop         -2.15e- 8   8.62e-9   -2.49   1.32e- 2\n15 Americas  year         3.00e- 1   2.08e-2   14.4    3.79e-36\n16 Americas  gdpPercap    6.75e- 4   7.15e-5    9.44   1.13e-18\n17 Oceania   (Intercept) -2.10e+ 2   5.12e+1   -4.10   5.61e- 4\n18 Oceania   pop          8.37e- 9   3.34e-8    0.251  8.05e- 1\n19 Oceania   year         1.42e- 1   2.65e-2    5.34   3.19e- 5\n20 Oceania   gdpPercap    2.03e- 4   8.47e-5    2.39   2.66e- 2\n```\n\n\n:::\n:::\n",
    "supporting": [
      "2019-08-19_purrr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}